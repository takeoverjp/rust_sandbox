/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _NETINET_IN_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MAX: u32 = 45;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MAX: u32 = 45;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _STDIO_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _TERMIOS_H: u32 = 1;
pub const NCCS: u32 = 32;
pub const _HAVE_STRUCT_TERMIOS_C_ISPEED: u32 = 1;
pub const _HAVE_STRUCT_TERMIOS_C_OSPEED: u32 = 1;
pub const VINTR: u32 = 0;
pub const VQUIT: u32 = 1;
pub const VERASE: u32 = 2;
pub const VKILL: u32 = 3;
pub const VEOF: u32 = 4;
pub const VTIME: u32 = 5;
pub const VMIN: u32 = 6;
pub const VSWTC: u32 = 7;
pub const VSTART: u32 = 8;
pub const VSTOP: u32 = 9;
pub const VSUSP: u32 = 10;
pub const VEOL: u32 = 11;
pub const VREPRINT: u32 = 12;
pub const VDISCARD: u32 = 13;
pub const VWERASE: u32 = 14;
pub const VLNEXT: u32 = 15;
pub const VEOL2: u32 = 16;
pub const IGNBRK: u32 = 1;
pub const BRKINT: u32 = 2;
pub const IGNPAR: u32 = 4;
pub const PARMRK: u32 = 8;
pub const INPCK: u32 = 16;
pub const ISTRIP: u32 = 32;
pub const INLCR: u32 = 64;
pub const IGNCR: u32 = 128;
pub const ICRNL: u32 = 256;
pub const IUCLC: u32 = 512;
pub const IXON: u32 = 1024;
pub const IXANY: u32 = 2048;
pub const IXOFF: u32 = 4096;
pub const IMAXBEL: u32 = 8192;
pub const IUTF8: u32 = 16384;
pub const OPOST: u32 = 1;
pub const OLCUC: u32 = 2;
pub const ONLCR: u32 = 4;
pub const OCRNL: u32 = 8;
pub const ONOCR: u32 = 16;
pub const ONLRET: u32 = 32;
pub const OFILL: u32 = 64;
pub const OFDEL: u32 = 128;
pub const NLDLY: u32 = 256;
pub const NL0: u32 = 0;
pub const NL1: u32 = 256;
pub const CRDLY: u32 = 1536;
pub const CR0: u32 = 0;
pub const CR1: u32 = 512;
pub const CR2: u32 = 1024;
pub const CR3: u32 = 1536;
pub const TABDLY: u32 = 6144;
pub const TAB0: u32 = 0;
pub const TAB1: u32 = 2048;
pub const TAB2: u32 = 4096;
pub const TAB3: u32 = 6144;
pub const BSDLY: u32 = 8192;
pub const BS0: u32 = 0;
pub const BS1: u32 = 8192;
pub const FFDLY: u32 = 32768;
pub const FF0: u32 = 0;
pub const FF1: u32 = 32768;
pub const VTDLY: u32 = 16384;
pub const VT0: u32 = 0;
pub const VT1: u32 = 16384;
pub const XTABS: u32 = 6144;
pub const B0: u32 = 0;
pub const B50: u32 = 1;
pub const B75: u32 = 2;
pub const B110: u32 = 3;
pub const B134: u32 = 4;
pub const B150: u32 = 5;
pub const B200: u32 = 6;
pub const B300: u32 = 7;
pub const B600: u32 = 8;
pub const B1200: u32 = 9;
pub const B1800: u32 = 10;
pub const B2400: u32 = 11;
pub const B4800: u32 = 12;
pub const B9600: u32 = 13;
pub const B19200: u32 = 14;
pub const B38400: u32 = 15;
pub const EXTA: u32 = 14;
pub const EXTB: u32 = 15;
pub const CBAUD: u32 = 4111;
pub const CBAUDEX: u32 = 4096;
pub const CIBAUD: u32 = 269418496;
pub const CMSPAR: u32 = 1073741824;
pub const CRTSCTS: u32 = 2147483648;
pub const B57600: u32 = 4097;
pub const B115200: u32 = 4098;
pub const B230400: u32 = 4099;
pub const B460800: u32 = 4100;
pub const B500000: u32 = 4101;
pub const B576000: u32 = 4102;
pub const B921600: u32 = 4103;
pub const B1000000: u32 = 4104;
pub const B1152000: u32 = 4105;
pub const B1500000: u32 = 4106;
pub const B2000000: u32 = 4107;
pub const B2500000: u32 = 4108;
pub const B3000000: u32 = 4109;
pub const B3500000: u32 = 4110;
pub const B4000000: u32 = 4111;
pub const __MAX_BAUD: u32 = 4111;
pub const CSIZE: u32 = 48;
pub const CS5: u32 = 0;
pub const CS6: u32 = 16;
pub const CS7: u32 = 32;
pub const CS8: u32 = 48;
pub const CSTOPB: u32 = 64;
pub const CREAD: u32 = 128;
pub const PARENB: u32 = 256;
pub const PARODD: u32 = 512;
pub const HUPCL: u32 = 1024;
pub const CLOCAL: u32 = 2048;
pub const ISIG: u32 = 1;
pub const ICANON: u32 = 2;
pub const XCASE: u32 = 4;
pub const ECHO: u32 = 8;
pub const ECHOE: u32 = 16;
pub const ECHOK: u32 = 32;
pub const ECHONL: u32 = 64;
pub const NOFLSH: u32 = 128;
pub const TOSTOP: u32 = 256;
pub const ECHOCTL: u32 = 512;
pub const ECHOPRT: u32 = 1024;
pub const ECHOKE: u32 = 2048;
pub const FLUSHO: u32 = 4096;
pub const PENDIN: u32 = 16384;
pub const IEXTEN: u32 = 32768;
pub const EXTPROC: u32 = 65536;
pub const TIOCSER_TEMT: u32 = 1;
pub const TCOOFF: u32 = 0;
pub const TCOON: u32 = 1;
pub const TCIOFF: u32 = 2;
pub const TCION: u32 = 3;
pub const TCIFLUSH: u32 = 0;
pub const TCOFLUSH: u32 = 1;
pub const TCIOFLUSH: u32 = 2;
pub const TCSANOW: u32 = 0;
pub const TCSADRAIN: u32 = 1;
pub const TCSAFLUSH: u32 = 2;
pub const TTYDEF_IFLAG: u32 = 11554;
pub const TTYDEF_OFLAG: u32 = 6149;
pub const TTYDEF_LFLAG: u32 = 35355;
pub const TTYDEF_CFLAG: u32 = 1440;
pub const TTYDEF_SPEED: u32 = 13;
pub const CEOL: u8 = 0u8;
pub const CERASE: u32 = 127;
pub const CSTATUS: u8 = 0u8;
pub const CMIN: u32 = 1;
pub const CQUIT: u32 = 28;
pub const CTIME: u32 = 0;
pub const CBRK: u8 = 0u8;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const DLT_MAINTAIN_LOGSTORAGE_LOGLEVEL_UNDEF: i32 = -1;
pub const DLT_MAINTAIN_LOGSTORAGE_LOGLEVEL_OFF: u32 = 0;
pub const DLT_MAINTAIN_LOGSTORAGE_LOGLEVEL_ON: u32 = 1;
pub const DLT_HTYP_UEH: u32 = 1;
pub const DLT_HTYP_MSBF: u32 = 2;
pub const DLT_HTYP_WEID: u32 = 4;
pub const DLT_HTYP_WSID: u32 = 8;
pub const DLT_HTYP_WTMS: u32 = 16;
pub const DLT_HTYP_VERS: u32 = 224;
pub const DLT_HTYP_PROTOCOL_VERSION1: u32 = 32;
pub const DLT_MSIN_VERB: u32 = 1;
pub const DLT_MSIN_MSTP: u32 = 14;
pub const DLT_MSIN_MTIN: u32 = 240;
pub const DLT_MSIN_MSTP_SHIFT: u32 = 1;
pub const DLT_MSIN_MTIN_SHIFT: u32 = 4;
pub const DLT_TYPE_LOG: u32 = 0;
pub const DLT_TYPE_APP_TRACE: u32 = 1;
pub const DLT_TYPE_NW_TRACE: u32 = 2;
pub const DLT_TYPE_CONTROL: u32 = 3;
pub const DLT_TRACE_VARIABLE: u32 = 1;
pub const DLT_TRACE_FUNCTION_IN: u32 = 2;
pub const DLT_TRACE_FUNCTION_OUT: u32 = 3;
pub const DLT_TRACE_STATE: u32 = 4;
pub const DLT_TRACE_VFB: u32 = 5;
pub const DLT_CONTROL_REQUEST: u32 = 1;
pub const DLT_CONTROL_RESPONSE: u32 = 2;
pub const DLT_CONTROL_TIME: u32 = 3;
pub const DLT_MSIN_CONTROL_REQUEST: u32 = 22;
pub const DLT_MSIN_CONTROL_RESPONSE: u32 = 38;
pub const DLT_MSIN_CONTROL_TIME: u32 = 54;
pub const DLT_TYPE_INFO_TYLE: u32 = 15;
pub const DLT_TYPE_INFO_BOOL: u32 = 16;
pub const DLT_TYPE_INFO_SINT: u32 = 32;
pub const DLT_TYPE_INFO_UINT: u32 = 64;
pub const DLT_TYPE_INFO_FLOA: u32 = 128;
pub const DLT_TYPE_INFO_ARAY: u32 = 256;
pub const DLT_TYPE_INFO_STRG: u32 = 512;
pub const DLT_TYPE_INFO_RAWD: u32 = 1024;
pub const DLT_TYPE_INFO_VARI: u32 = 2048;
pub const DLT_TYPE_INFO_FIXP: u32 = 4096;
pub const DLT_TYPE_INFO_TRAI: u32 = 8192;
pub const DLT_TYPE_INFO_STRU: u32 = 16384;
pub const DLT_TYPE_INFO_SCOD: u32 = 229376;
pub const DLT_TYLE_8BIT: u32 = 1;
pub const DLT_TYLE_16BIT: u32 = 2;
pub const DLT_TYLE_32BIT: u32 = 3;
pub const DLT_TYLE_64BIT: u32 = 4;
pub const DLT_TYLE_128BIT: u32 = 5;
pub const DLT_SCOD_ASCII: u32 = 0;
pub const DLT_SCOD_UTF8: u32 = 32768;
pub const DLT_SCOD_HEX: u32 = 65536;
pub const DLT_SCOD_BIN: u32 = 98304;
pub const DLT_SERVICE_ID_CALLSW_CINJECTION: u32 = 4095;
pub const DLT_SERVICE_RESPONSE_OK: u32 = 0;
pub const DLT_SERVICE_RESPONSE_NOT_SUPPORTED: u32 = 1;
pub const DLT_SERVICE_RESPONSE_ERROR: u32 = 2;
pub const DLT_SERVICE_RESPONSE_PERM_DENIED: u32 = 3;
pub const DLT_SERVICE_RESPONSE_WARNING: u32 = 4;
pub const DLT_SERVICE_RESPONSE_LAST: u32 = 5;
pub const DLT_CONNECTION_STATUS_DISCONNECTED: u32 = 1;
pub const DLT_CONNECTION_STATUS_CONNECTED: u32 = 2;
pub const GET_LOG_INFO_STATUS_MIN: u32 = 3;
pub const GET_LOG_INFO_STATUS_MAX: u32 = 7;
pub const GET_LOG_INFO_STATUS_NO_MATCHING_CTX: u32 = 8;
pub const GET_LOG_INFO_STATUS_RESP_DATA_OVERFLOW: u32 = 9;
pub const DLT_DAEMON_TCP_PORT: u32 = 3490;
pub const DLT_FD_INIT: i32 = -1;
pub const DLT_FD_MINIMUM: u32 = 3;
pub const DLT_ID_SIZE: u32 = 4;
pub const DLT_SIZE_WEID: u32 = 4;
pub const DLT_CONVERT_TEXTBUFSIZE: u32 = 10024;
pub const DLT_GET_LOG_INFO_HEADER: u32 = 18;
pub const GET_LOG_INFO_LENGTH: u32 = 13;
pub const SERVICE_OPT_LENGTH: u32 = 3;
pub const DLT_MESSAGE_BUFFER_NO_OVERFLOW: u32 = 0;
pub const DLT_MESSAGE_BUFFER_OVERFLOW: u32 = 1;
pub const DLT_OUTPUT_HEX: u32 = 1;
pub const DLT_OUTPUT_ASCII: u32 = 2;
pub const DLT_OUTPUT_MIXED_FOR_PLAIN: u32 = 3;
pub const DLT_OUTPUT_MIXED_FOR_HTML: u32 = 4;
pub const DLT_OUTPUT_ASCII_LIMITED: u32 = 5;
pub const DLT_FILTER_MAX: u32 = 30;
pub const DLT_HEADER_SHOW_NONE: u32 = 0;
pub const DLT_HEADER_SHOW_TIME: u32 = 1;
pub const DLT_HEADER_SHOW_TMSTP: u32 = 2;
pub const DLT_HEADER_SHOW_MSGCNT: u32 = 4;
pub const DLT_HEADER_SHOW_ECUID: u32 = 8;
pub const DLT_HEADER_SHOW_APID: u32 = 16;
pub const DLT_HEADER_SHOW_CTID: u32 = 32;
pub const DLT_HEADER_SHOW_MSGTYPE: u32 = 64;
pub const DLT_HEADER_SHOW_MSGSUBTYPE: u32 = 128;
pub const DLT_HEADER_SHOW_VNVSTATUS: u32 = 256;
pub const DLT_HEADER_SHOW_NOARG: u32 = 512;
pub const DLT_HEADER_SHOW_ALL: u32 = 65535;
pub const DLT_RCV_NONE: u32 = 0;
pub const DLT_RCV_SKIP_HEADER: u32 = 1;
pub const DLT_RCV_REMOVE: u32 = 2;
pub const DLT_PATH_MAX: u32 = 1024;
pub const DLT_MOUNT_PATH_MAX: u32 = 1024;
pub const DLT_ENTRY_MAX: u32 = 100;
pub const DLT_IPC_PATH_MAX: u32 = 100;
pub const DLT_RECEIVE_BUFSIZE: u32 = 65535;
pub const DLT_LINE_LEN: u32 = 1024;
pub const DLT_TRACE_NW_TRUNCATED: &[u8; 5usize] = b"NWTR\0";
pub const DLT_TRACE_NW_START: &[u8; 5usize] = b"NWST\0";
pub const DLT_TRACE_NW_SEGMENT: &[u8; 5usize] = b"NWCH\0";
pub const DLT_TRACE_NW_END: &[u8; 5usize] = b"NWEN\0";
pub const DLT_BUFFER_HEAD: &[u8; 4usize] = b"SHM\0";
pub const DLT_IP_SIZE: u32 = 16;
pub const DLT_MESSAGE_ERROR_OK: u32 = 0;
pub const DLT_MESSAGE_ERROR_UNKNOWN: i32 = -1;
pub const DLT_MESSAGE_ERROR_SIZE: i32 = -2;
pub const DLT_MESSAGE_ERROR_CONTENT: i32 = -3;
pub const DLT_DISABLE_MACRO: u32 = 0;
pub const _MQUEUE_H: u32 = 1;
pub const _FCNTL_H: u32 = 1;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const _BITS_STAT_H: u32 = 1;
pub const _STAT_VER_KERNEL: u32 = 0;
pub const _STAT_VER_LINUX: u32 = 1;
pub const _MKNOD_VER_LINUX: u32 = 0;
pub const _STAT_VER: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const _SEMAPHORE_H: u32 = 1;
pub const __SIZEOF_SEM_T: u32 = 32;
pub const DLT_SHM_SIZE: u32 = 100000;
pub const _DLT_PACKAGE_VERSION_STATE: &[u8; 7usize] = b"STABLE\0";
pub const _DLT_PACKAGE_VERSION: &[u8; 7usize] = b"2.18.8\0";
pub const _DLT_PACKAGE_MAJOR_VERSION: &[u8; 2usize] = b"2\0";
pub const _DLT_PACKAGE_MINOR_VERSION: &[u8; 3usize] = b"18\0";
pub const _DLT_PACKAGE_PATCH_LEVEL: &[u8; 2usize] = b"8\0";
pub const _DLT_PACKAGE_REVISION: &[u8; 8usize] = b"v2.18.8\0";
pub const _DLT_SYSTEMD_ENABLE: &[u8; 9usize] = b"-SYSTEMD\0";
pub const _DLT_SYSTEMD_WATCHDOG_ENABLE: &[u8; 18usize] = b"-SYSTEMD_WATCHDOG\0";
pub const _DLT_TEST_ENABLE: &[u8; 6usize] = b"-TEST\0";
pub const _DLT_SHM_ENABLE: &[u8; 5usize] = b"-SHM\0";
pub const DLT_USER_BUF_MAX_SIZE: u32 = 1390;
pub const DLT_USER_RESENDBUF_MAX_SIZE: u32 = 1490;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type socklen_t = __socklen_t;
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
pub const MSG_OOB: _bindgen_ty_1 = 1;
pub const MSG_PEEK: _bindgen_ty_1 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_1 = 4;
pub const MSG_CTRUNC: _bindgen_ty_1 = 8;
pub const MSG_PROXY: _bindgen_ty_1 = 16;
pub const MSG_TRUNC: _bindgen_ty_1 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_1 = 64;
pub const MSG_EOR: _bindgen_ty_1 = 128;
pub const MSG_WAITALL: _bindgen_ty_1 = 256;
pub const MSG_FIN: _bindgen_ty_1 = 512;
pub const MSG_SYN: _bindgen_ty_1 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_1 = 2048;
pub const MSG_RST: _bindgen_ty_1 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_1 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_1 = 16384;
pub const MSG_MORE: _bindgen_ty_1 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_1 = 65536;
pub const MSG_BATCH: _bindgen_ty_1 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_1 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_1 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_1 = 1073741824;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cmsg_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<osockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: _bindgen_ty_3 = 0;
pub const SHUT_WR: _bindgen_ty_3 = 1;
pub const SHUT_RDWR: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    const UNINIT: ::std::mem::MaybeUninit<ip_opts> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_opts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreqn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_ifindex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_spec_dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
pub const IPPROTO_IP: _bindgen_ty_4 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_4 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_4 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_4 = 4;
pub const IPPROTO_TCP: _bindgen_ty_4 = 6;
pub const IPPROTO_EGP: _bindgen_ty_4 = 8;
pub const IPPROTO_PUP: _bindgen_ty_4 = 12;
pub const IPPROTO_UDP: _bindgen_ty_4 = 17;
pub const IPPROTO_IDP: _bindgen_ty_4 = 22;
pub const IPPROTO_TP: _bindgen_ty_4 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_4 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_4 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_4 = 46;
pub const IPPROTO_GRE: _bindgen_ty_4 = 47;
pub const IPPROTO_ESP: _bindgen_ty_4 = 50;
pub const IPPROTO_AH: _bindgen_ty_4 = 51;
pub const IPPROTO_MTP: _bindgen_ty_4 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_4 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_4 = 98;
pub const IPPROTO_PIM: _bindgen_ty_4 = 103;
pub const IPPROTO_COMP: _bindgen_ty_4 = 108;
pub const IPPROTO_SCTP: _bindgen_ty_4 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_4 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_4 = 137;
pub const IPPROTO_RAW: _bindgen_ty_4 = 255;
pub const IPPROTO_MAX: _bindgen_ty_4 = 256;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const IPPROTO_HOPOPTS: _bindgen_ty_5 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_5 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_5 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_5 = 58;
pub const IPPROTO_NONE: _bindgen_ty_5 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_5 = 60;
pub const IPPROTO_MH: _bindgen_ty_5 = 135;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_6 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_6 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_6 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_6 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_6 = 15;
pub const IPPORT_FTP: _bindgen_ty_6 = 21;
pub const IPPORT_TELNET: _bindgen_ty_6 = 23;
pub const IPPORT_SMTP: _bindgen_ty_6 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_6 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_6 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_6 = 43;
pub const IPPORT_MTP: _bindgen_ty_6 = 57;
pub const IPPORT_TFTP: _bindgen_ty_6 = 69;
pub const IPPORT_RJE: _bindgen_ty_6 = 77;
pub const IPPORT_FINGER: _bindgen_ty_6 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_6 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_6 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_6 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_6 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_6 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_6 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_6 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_6 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_6 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_6 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_6 = 5000;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__in6_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq_source> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_sourceaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ipv6_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_source_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_source) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    const UNINIT: ::std::mem::MaybeUninit<ip_msfilter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_fmode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_numsrc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imsf_slist) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    const UNINIT: ::std::mem::MaybeUninit<group_filter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_fmode) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_numsrc) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gf_slist) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type useconds_t = __useconds_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_7 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_7 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_7 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_7 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_7 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_7 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_7 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_7 = 7;
pub const _PC_VDISABLE: _bindgen_ty_7 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_7 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_7 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_7 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_7 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_7 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_7 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_7 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_7 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_7 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_7 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_7 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_7 = 20;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_8 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_8 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_8 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_8 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_8 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_8 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_8 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_8 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_8 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_8 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_8 = 10;
pub const _SC_TIMERS: _bindgen_ty_8 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_8 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_8 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_8 = 14;
pub const _SC_FSYNC: _bindgen_ty_8 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_8 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_8 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_8 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_8 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_8 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_8 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_8 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_8 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_8 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_8 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_8 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_8 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_8 = 28;
pub const _SC_VERSION: _bindgen_ty_8 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_8 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_8 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_8 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_8 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_8 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_8 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_8 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_8 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_8 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_8 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_8 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_8 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_8 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_8 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_8 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_8 = 45;
pub const _SC_2_VERSION: _bindgen_ty_8 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_8 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_8 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_8 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_8 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_8 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_8 = 52;
pub const _SC_PII: _bindgen_ty_8 = 53;
pub const _SC_PII_XTI: _bindgen_ty_8 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_8 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_8 = 56;
pub const _SC_PII_OSI: _bindgen_ty_8 = 57;
pub const _SC_POLL: _bindgen_ty_8 = 58;
pub const _SC_SELECT: _bindgen_ty_8 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_8 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_8 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_8 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_8 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_8 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_8 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_8 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_8 = 66;
pub const _SC_THREADS: _bindgen_ty_8 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_8 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_8 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_8 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_8 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_8 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_8 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_8 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_8 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_8 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_8 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_8 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_8 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_8 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_8 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_8 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_8 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_8 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_8 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_8 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_8 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_8 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_8 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_8 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_8 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_8 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_8 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_8 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_8 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_8 = 96;
pub const _SC_2_UPE: _bindgen_ty_8 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_8 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_8 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_8 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_8 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_8 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_8 = 103;
pub const _SC_INT_MAX: _bindgen_ty_8 = 104;
pub const _SC_INT_MIN: _bindgen_ty_8 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_8 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_8 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_8 = 108;
pub const _SC_NZERO: _bindgen_ty_8 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_8 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_8 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_8 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_8 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_8 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_8 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_8 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_8 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_8 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_8 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_8 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_8 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_8 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_8 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_8 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_8 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_8 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_8 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_8 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_8 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_8 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_8 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_8 = 132;
pub const _SC_BARRIERS: _bindgen_ty_8 = 133;
pub const _SC_BASE: _bindgen_ty_8 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_8 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_8 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_8 = 137;
pub const _SC_CPUTIME: _bindgen_ty_8 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_8 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_8 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_8 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_8 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_8 = 143;
pub const _SC_FIFO: _bindgen_ty_8 = 144;
pub const _SC_PIPE: _bindgen_ty_8 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_8 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_8 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_8 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_8 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_8 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_8 = 151;
pub const _SC_NETWORKING: _bindgen_ty_8 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_8 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_8 = 154;
pub const _SC_REGEXP: _bindgen_ty_8 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_8 = 156;
pub const _SC_SHELL: _bindgen_ty_8 = 157;
pub const _SC_SIGNALS: _bindgen_ty_8 = 158;
pub const _SC_SPAWN: _bindgen_ty_8 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_8 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_8 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_8 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_8 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_8 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_8 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_8 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_8 = 167;
pub const _SC_2_PBS: _bindgen_ty_8 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_8 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_8 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_8 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_8 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_8 = 173;
pub const _SC_STREAMS: _bindgen_ty_8 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_8 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_8 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_8 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_8 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_8 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_8 = 180;
pub const _SC_TRACE: _bindgen_ty_8 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_8 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_8 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_8 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_8 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_8 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_8 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_8 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_8 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_8 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_8 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_8 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_8 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_8 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_8 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_8 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_8 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_8 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_8 = 199;
pub const _SC_IPV6: _bindgen_ty_8 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_8 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_8 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_8 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_8 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_8 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_8 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_8 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_8 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_8 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_8 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_8 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_8 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_8 = 248;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_9 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_9 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_9 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_9 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_9 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_9 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_9 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_9 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_9 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_9 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_9 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_9 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_9 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_9 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_9 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_9 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_9 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_9 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_9 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_9 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_9 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_9 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_9 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_9 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_9 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_9 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_9 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_9 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_9 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_9 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_9 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_9 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_9 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_9 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_9 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_9 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_9 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_9 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_9 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_9 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_9 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_9 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_9 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_9 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_9 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_9 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_9 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_9 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_9 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_9 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_9 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_9 = 1149;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type cc_t = ::std::os::raw::c_uchar;
pub type speed_t = ::std::os::raw::c_uint;
pub type tcflag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_line: cc_t,
    pub c_cc: [cc_t; 32usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    const UNINIT: ::std::mem::MaybeUninit<termios> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<termios>(),
        60usize,
        concat!("Size of: ", stringify!(termios))
    );
    assert_eq!(
        ::std::mem::align_of::<termios>(),
        4usize,
        concat!("Alignment of ", stringify!(termios))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_iflag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_iflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_oflag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_oflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_cflag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_lflag) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_lflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_line) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_cc) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_cc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_ispeed) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_ispeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_ospeed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(termios),
            "::",
            stringify!(c_ospeed)
        )
    );
}
extern "C" {
    pub fn cfgetospeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfgetispeed(__termios_p: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfsetospeed(__termios_p: *mut termios, __speed: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfsetispeed(__termios_p: *mut termios, __speed: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfsetspeed(__termios_p: *mut termios, __speed: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetattr(
        __fd: ::std::os::raw::c_int,
        __termios_p: *mut termios,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcsetattr(
        __fd: ::std::os::raw::c_int,
        __optional_actions: ::std::os::raw::c_int,
        __termios_p: *const termios,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfmakeraw(__termios_p: *mut termios);
}
extern "C" {
    pub fn tcsendbreak(
        __fd: ::std::os::raw::c_int,
        __duration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcdrain(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflush(
        __fd: ::std::os::raw::c_int,
        __queue_selector: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflow(
        __fd: ::std::os::raw::c_int,
        __action: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetsid(__fd: ::std::os::raw::c_int) -> __pid_t;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const DltReturnValue_DLT_RETURN_FILESZERR: DltReturnValue = -8;
pub const DltReturnValue_DLT_RETURN_LOGGING_DISABLED: DltReturnValue = -7;
pub const DltReturnValue_DLT_RETURN_USER_BUFFER_FULL: DltReturnValue = -6;
pub const DltReturnValue_DLT_RETURN_WRONG_PARAMETER: DltReturnValue = -5;
pub const DltReturnValue_DLT_RETURN_BUFFER_FULL: DltReturnValue = -4;
pub const DltReturnValue_DLT_RETURN_PIPE_FULL: DltReturnValue = -3;
pub const DltReturnValue_DLT_RETURN_PIPE_ERROR: DltReturnValue = -2;
pub const DltReturnValue_DLT_RETURN_ERROR: DltReturnValue = -1;
pub const DltReturnValue_DLT_RETURN_OK: DltReturnValue = 0;
pub const DltReturnValue_DLT_RETURN_TRUE: DltReturnValue = 1;
#[doc = " Definitions of DLT return values"]
pub type DltReturnValue = ::std::os::raw::c_int;
#[doc = "< Default log level"]
pub const DltLogLevelType_DLT_LOG_DEFAULT: DltLogLevelType = -1;
#[doc = "< Log level off"]
pub const DltLogLevelType_DLT_LOG_OFF: DltLogLevelType = 0;
#[doc = "< fatal system error"]
pub const DltLogLevelType_DLT_LOG_FATAL: DltLogLevelType = 1;
#[doc = "< error with impact to correct functionality"]
pub const DltLogLevelType_DLT_LOG_ERROR: DltLogLevelType = 2;
#[doc = "< warning, correct behaviour could not be ensured"]
pub const DltLogLevelType_DLT_LOG_WARN: DltLogLevelType = 3;
#[doc = "< informational"]
pub const DltLogLevelType_DLT_LOG_INFO: DltLogLevelType = 4;
#[doc = "< debug"]
pub const DltLogLevelType_DLT_LOG_DEBUG: DltLogLevelType = 5;
#[doc = "< highest grade of information"]
pub const DltLogLevelType_DLT_LOG_VERBOSE: DltLogLevelType = 6;
#[doc = "< maximum value, used for range check"]
pub const DltLogLevelType_DLT_LOG_MAX: DltLogLevelType = 7;
#[doc = " Definitions of DLT log level"]
pub type DltLogLevelType = ::std::os::raw::c_int;
#[doc = "< no sepecial format"]
pub const DltFormatType_DLT_FORMAT_DEFAULT: DltFormatType = 0;
#[doc = "< Hex 8"]
pub const DltFormatType_DLT_FORMAT_HEX8: DltFormatType = 1;
#[doc = "< Hex 16"]
pub const DltFormatType_DLT_FORMAT_HEX16: DltFormatType = 2;
#[doc = "< Hex 32"]
pub const DltFormatType_DLT_FORMAT_HEX32: DltFormatType = 3;
#[doc = "< Hex 64"]
pub const DltFormatType_DLT_FORMAT_HEX64: DltFormatType = 4;
#[doc = "< Binary 8"]
pub const DltFormatType_DLT_FORMAT_BIN8: DltFormatType = 5;
#[doc = "< Binary 16"]
pub const DltFormatType_DLT_FORMAT_BIN16: DltFormatType = 6;
#[doc = "< maximum value, used for range check"]
pub const DltFormatType_DLT_FORMAT_MAX: DltFormatType = 7;
#[doc = " Definitions of DLT Format"]
pub type DltFormatType = ::std::os::raw::c_uint;
#[doc = "< Default trace status"]
pub const DltTraceStatusType_DLT_TRACE_STATUS_DEFAULT: DltTraceStatusType = -1;
#[doc = "< Trace status: Off"]
pub const DltTraceStatusType_DLT_TRACE_STATUS_OFF: DltTraceStatusType = 0;
#[doc = "< Trace status: On"]
pub const DltTraceStatusType_DLT_TRACE_STATUS_ON: DltTraceStatusType = 1;
#[doc = "< maximum value, used for range check"]
pub const DltTraceStatusType_DLT_TRACE_STATUS_MAX: DltTraceStatusType = 2;
#[doc = " Definitions of DLT trace status"]
pub type DltTraceStatusType = ::std::os::raw::c_int;
#[doc = "< Interprocess communication"]
pub const DltNetworkTraceType_DLT_NW_TRACE_IPC: DltNetworkTraceType = 1;
#[doc = "< Controller Area Network Bus"]
pub const DltNetworkTraceType_DLT_NW_TRACE_CAN: DltNetworkTraceType = 2;
#[doc = "< Flexray Bus"]
pub const DltNetworkTraceType_DLT_NW_TRACE_FLEXRAY: DltNetworkTraceType = 3;
#[doc = "< Media Oriented System Transport Bus"]
pub const DltNetworkTraceType_DLT_NW_TRACE_MOST: DltNetworkTraceType = 4;
pub const DltNetworkTraceType_DLT_NW_TRACE_RESERVED0: DltNetworkTraceType = 5;
pub const DltNetworkTraceType_DLT_NW_TRACE_RESERVED1: DltNetworkTraceType = 6;
pub const DltNetworkTraceType_DLT_NW_TRACE_RESERVED2: DltNetworkTraceType = 7;
pub const DltNetworkTraceType_DLT_NW_TRACE_USER_DEFINED0: DltNetworkTraceType = 8;
pub const DltNetworkTraceType_DLT_NW_TRACE_USER_DEFINED1: DltNetworkTraceType = 9;
pub const DltNetworkTraceType_DLT_NW_TRACE_USER_DEFINED2: DltNetworkTraceType = 10;
pub const DltNetworkTraceType_DLT_NW_TRACE_USER_DEFINED3: DltNetworkTraceType = 11;
pub const DltNetworkTraceType_DLT_NW_TRACE_USER_DEFINED4: DltNetworkTraceType = 12;
pub const DltNetworkTraceType_DLT_NW_TRACE_USER_DEFINED5: DltNetworkTraceType = 13;
pub const DltNetworkTraceType_DLT_NW_TRACE_USER_DEFINED6: DltNetworkTraceType = 14;
#[doc = "< Mark a resend"]
pub const DltNetworkTraceType_DLT_NW_TRACE_RESEND: DltNetworkTraceType = 15;
#[doc = "< maximum value, used for range check"]
pub const DltNetworkTraceType_DLT_NW_TRACE_MAX: DltNetworkTraceType = 16;
#[doc = " Definitions for  dlt_user_trace_network/DLT_TRACE_NETWORK()\n as defined in the DLT protocol"]
pub type DltNetworkTraceType = ::std::os::raw::c_uint;
pub const DltUserLogMode_DLT_USER_MODE_UNDEFINED: DltUserLogMode = -1;
pub const DltUserLogMode_DLT_USER_MODE_OFF: DltUserLogMode = 0;
pub const DltUserLogMode_DLT_USER_MODE_EXTERNAL: DltUserLogMode = 1;
pub const DltUserLogMode_DLT_USER_MODE_INTERNAL: DltUserLogMode = 2;
pub const DltUserLogMode_DLT_USER_MODE_BOTH: DltUserLogMode = 3;
#[doc = "< maximum value, used for range check"]
pub const DltUserLogMode_DLT_USER_MODE_MAX: DltUserLogMode = 4;
#[doc = " This are the log modes."]
pub type DltUserLogMode = ::std::os::raw::c_int;
pub type float32_t = f32;
pub type float64_t = f64;
pub const DltTimestampType_DLT_AUTO_TIMESTAMP: DltTimestampType = 0;
pub const DltTimestampType_DLT_USER_TIMESTAMP: DltTimestampType = 1;
#[doc = " Definition of timestamp types"]
pub type DltTimestampType = ::std::os::raw::c_uint;
pub const dlt_services_DLT_SERVICE_ID: dlt_services = 0;
pub const dlt_services_DLT_SERVICE_ID_SET_LOG_LEVEL: dlt_services = 1;
pub const dlt_services_DLT_SERVICE_ID_SET_TRACE_STATUS: dlt_services = 2;
pub const dlt_services_DLT_SERVICE_ID_GET_LOG_INFO: dlt_services = 3;
pub const dlt_services_DLT_SERVICE_ID_GET_DEFAULT_LOG_LEVEL: dlt_services = 4;
pub const dlt_services_DLT_SERVICE_ID_STORE_CONFIG: dlt_services = 5;
pub const dlt_services_DLT_SERVICE_ID_RESET_TO_FACTORY_DEFAULT: dlt_services = 6;
pub const dlt_services_DLT_SERVICE_ID_SET_COM_INTERFACE_STATUS: dlt_services = 7;
pub const dlt_services_DLT_SERVICE_ID_SET_COM_INTERFACE_MAX_BANDWIDTH: dlt_services = 8;
pub const dlt_services_DLT_SERVICE_ID_SET_VERBOSE_MODE: dlt_services = 9;
pub const dlt_services_DLT_SERVICE_ID_SET_MESSAGE_FILTERING: dlt_services = 10;
pub const dlt_services_DLT_SERVICE_ID_SET_TIMING_PACKETS: dlt_services = 11;
pub const dlt_services_DLT_SERVICE_ID_GET_LOCAL_TIME: dlt_services = 12;
pub const dlt_services_DLT_SERVICE_ID_USE_ECU_ID: dlt_services = 13;
pub const dlt_services_DLT_SERVICE_ID_USE_SESSION_ID: dlt_services = 14;
pub const dlt_services_DLT_SERVICE_ID_USE_TIMESTAMP: dlt_services = 15;
pub const dlt_services_DLT_SERVICE_ID_USE_EXTENDED_HEADER: dlt_services = 16;
pub const dlt_services_DLT_SERVICE_ID_SET_DEFAULT_LOG_LEVEL: dlt_services = 17;
pub const dlt_services_DLT_SERVICE_ID_SET_DEFAULT_TRACE_STATUS: dlt_services = 18;
pub const dlt_services_DLT_SERVICE_ID_GET_SOFTWARE_VERSION: dlt_services = 19;
pub const dlt_services_DLT_SERVICE_ID_MESSAGE_BUFFER_OVERFLOW: dlt_services = 20;
pub const dlt_services_DLT_SERVICE_ID_LAST_ENTRY: dlt_services = 21;
pub type dlt_services = ::std::os::raw::c_uint;
pub const dlt_user_services_DLT_USER_SERVICE_ID: dlt_user_services = 3840;
pub const dlt_user_services_DLT_SERVICE_ID_UNREGISTER_CONTEXT: dlt_user_services = 3841;
pub const dlt_user_services_DLT_SERVICE_ID_CONNECTION_INFO: dlt_user_services = 3842;
pub const dlt_user_services_DLT_SERVICE_ID_TIMEZONE: dlt_user_services = 3843;
pub const dlt_user_services_DLT_SERVICE_ID_MARKER: dlt_user_services = 3844;
pub const dlt_user_services_DLT_SERVICE_ID_OFFLINE_LOGSTORAGE: dlt_user_services = 3845;
pub const dlt_user_services_DLT_SERVICE_ID_PASSIVE_NODE_CONNECT: dlt_user_services = 3846;
pub const dlt_user_services_DLT_SERVICE_ID_PASSIVE_NODE_CONNECTION_STATUS: dlt_user_services = 3847;
pub const dlt_user_services_DLT_SERVICE_ID_SET_ALL_LOG_LEVEL: dlt_user_services = 3848;
pub const dlt_user_services_DLT_SERVICE_ID_SET_ALL_TRACE_STATUS: dlt_user_services = 3849;
pub const dlt_user_services_DLT_SERVICE_ID_RESERVED_B: dlt_user_services = 3851;
pub const dlt_user_services_DLT_SERVICE_ID_RESERVED_C: dlt_user_services = 3852;
pub const dlt_user_services_DLT_SERVICE_ID_RESERVED_D: dlt_user_services = 3853;
pub const dlt_user_services_DLT_SERVICE_ID_RESERVED_E: dlt_user_services = 3854;
pub const dlt_user_services_DLT_USER_SERVICE_ID_LAST_ENTRY: dlt_user_services = 3855;
pub type dlt_user_services = ::std::os::raw::c_uint;
extern "C" {
    pub static dlt_service_names: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static dlt_user_service_names: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn dlt_get_service_name(id: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
pub const DLT_LOG_TO_CONSOLE: _bindgen_ty_10 = 0;
pub const DLT_LOG_TO_SYSLOG: _bindgen_ty_10 = 1;
pub const DLT_LOG_TO_FILE: _bindgen_ty_10 = 2;
pub const DLT_LOG_TO_STDERR: _bindgen_ty_10 = 3;
pub const DLT_LOG_DROPPED: _bindgen_ty_10 = 4;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const DltReceiverType_DLT_RECEIVE_SOCKET: DltReceiverType = 0;
pub const DltReceiverType_DLT_RECEIVE_UDP_SOCKET: DltReceiverType = 1;
pub const DltReceiverType_DLT_RECEIVE_FD: DltReceiverType = 2;
#[doc = " Type to specify whether received data is from socket or file/fifo"]
pub type DltReceiverType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " The definition of the serial header containing the characters \"DLS\" + 0x01."]
    pub static dltSerialHeader: [::std::os::raw::c_char; 4usize];
}
extern "C" {
    #[doc = " The definition of the serial header containing the characters \"DLS\" + 0x01 as char."]
    pub static mut dltSerialHeaderChar: [::std::os::raw::c_char; 4usize];
}
#[doc = " The type of a DLT ID (context id, application id, etc.)"]
pub type ID4 = [::std::os::raw::c_char; 4usize];
#[doc = " The structure of the DLT file storage header. This header is used before each stored DLT message."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltStorageHeader {
    #[doc = "< This pattern should be DLT0x01"]
    pub pattern: [::std::os::raw::c_char; 4usize],
    #[doc = "< seconds since 1.1.1970"]
    pub seconds: u32,
    #[doc = "< Microseconds"]
    pub microseconds: i32,
    #[doc = "< The ECU id is added, if it is not already in the DLT message itself"]
    pub ecu: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_DltStorageHeader() {
    const UNINIT: ::std::mem::MaybeUninit<DltStorageHeader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltStorageHeader>(),
        16usize,
        concat!("Size of: ", stringify!(DltStorageHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<DltStorageHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(DltStorageHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltStorageHeader),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seconds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltStorageHeader),
            "::",
            stringify!(seconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).microseconds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltStorageHeader),
            "::",
            stringify!(microseconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecu) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DltStorageHeader),
            "::",
            stringify!(ecu)
        )
    );
}
#[doc = " The structure of the DLT standard header. This header is used in each DLT message."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltStandardHeader {
    #[doc = "< This parameter contains several informations, see definitions below"]
    pub htyp: u8,
    #[doc = "< The message counter is increased with each sent DLT message"]
    pub mcnt: u8,
    #[doc = "< Length of the complete message, without storage header"]
    pub len: u16,
}
#[test]
fn bindgen_test_layout_DltStandardHeader() {
    const UNINIT: ::std::mem::MaybeUninit<DltStandardHeader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltStandardHeader>(),
        4usize,
        concat!("Size of: ", stringify!(DltStandardHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<DltStandardHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(DltStandardHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).htyp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltStandardHeader),
            "::",
            stringify!(htyp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcnt) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DltStandardHeader),
            "::",
            stringify!(mcnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DltStandardHeader),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " The structure of the DLT extra header parameters. Each parameter is sent only if enabled in htyp."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltStandardHeaderExtra {
    #[doc = "< ECU id"]
    pub ecu: [::std::os::raw::c_char; 4usize],
    #[doc = "< Session number"]
    pub seid: u32,
    #[doc = "< Timestamp since system start in 0.1 milliseconds"]
    pub tmsp: u32,
}
#[test]
fn bindgen_test_layout_DltStandardHeaderExtra() {
    const UNINIT: ::std::mem::MaybeUninit<DltStandardHeaderExtra> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltStandardHeaderExtra>(),
        12usize,
        concat!("Size of: ", stringify!(DltStandardHeaderExtra))
    );
    assert_eq!(
        ::std::mem::align_of::<DltStandardHeaderExtra>(),
        1usize,
        concat!("Alignment of ", stringify!(DltStandardHeaderExtra))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltStandardHeaderExtra),
            "::",
            stringify!(ecu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltStandardHeaderExtra),
            "::",
            stringify!(seid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmsp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltStandardHeaderExtra),
            "::",
            stringify!(tmsp)
        )
    );
}
#[doc = " The structure of the DLT extended header. This header is only sent if enabled in htyp parameter."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltExtendedHeader {
    #[doc = "< messsage info"]
    pub msin: u8,
    #[doc = "< number of arguments"]
    pub noar: u8,
    #[doc = "< application id"]
    pub apid: [::std::os::raw::c_char; 4usize],
    #[doc = "< context id"]
    pub ctid: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_DltExtendedHeader() {
    const UNINIT: ::std::mem::MaybeUninit<DltExtendedHeader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltExtendedHeader>(),
        10usize,
        concat!("Size of: ", stringify!(DltExtendedHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<DltExtendedHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(DltExtendedHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltExtendedHeader),
            "::",
            stringify!(msin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).noar) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DltExtendedHeader),
            "::",
            stringify!(noar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apid) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DltExtendedHeader),
            "::",
            stringify!(apid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctid) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(DltExtendedHeader),
            "::",
            stringify!(ctid)
        )
    );
}
#[doc = " The structure to organise the DLT messages.\n This structure is used by the corresponding functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sDltMessage {
    pub found_serialheader: i8,
    pub resync_offset: i32,
    #[doc = "< size of complete header including storage header"]
    pub headersize: i32,
    #[doc = "< size of complete payload"]
    pub datasize: i32,
    pub headerbuffer: [u8; 42usize],
    #[doc = "< buffer for loading payload"]
    pub databuffer: *mut u8,
    pub databuffersize: i32,
    #[doc = "< pointer to storage header of current loaded header"]
    pub storageheader: *mut DltStorageHeader,
    #[doc = "< pointer to standard header of current loaded header"]
    pub standardheader: *mut DltStandardHeader,
    #[doc = "< extra parameters of current loaded header"]
    pub headerextra: DltStandardHeaderExtra,
    #[doc = "< pointer to extended of current loaded header"]
    pub extendedheader: *mut DltExtendedHeader,
}
#[test]
fn bindgen_test_layout_sDltMessage() {
    const UNINIT: ::std::mem::MaybeUninit<sDltMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sDltMessage>(),
        120usize,
        concat!("Size of: ", stringify!(sDltMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<sDltMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(sDltMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).found_serialheader) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(found_serialheader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resync_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(resync_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headersize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(headersize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datasize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(datasize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headerbuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(headerbuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).databuffer) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(databuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).databuffersize) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(databuffersize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storageheader) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(storageheader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).standardheader) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(standardheader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headerextra) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(headerextra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extendedheader) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltMessage),
            "::",
            stringify!(extendedheader)
        )
    );
}
#[doc = " The structure to organise the DLT messages.\n This structure is used by the corresponding functions."]
pub type DltMessage = sDltMessage;
#[doc = " The structure of the DLT Service Get Log Info."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceGetLogInfoRequest {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< type of request"]
    pub options: u8,
    #[doc = "< application id"]
    pub apid: [::std::os::raw::c_char; 4usize],
    #[doc = "< context id"]
    pub ctid: [::std::os::raw::c_char; 4usize],
    #[doc = "< communication interface"]
    pub com: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_DltServiceGetLogInfoRequest() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceGetLogInfoRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceGetLogInfoRequest>(),
        17usize,
        concat!("Size of: ", stringify!(DltServiceGetLogInfoRequest))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceGetLogInfoRequest>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceGetLogInfoRequest))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetLogInfoRequest),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetLogInfoRequest),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apid) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetLogInfoRequest),
            "::",
            stringify!(apid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctid) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetLogInfoRequest),
            "::",
            stringify!(ctid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).com) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetLogInfoRequest),
            "::",
            stringify!(com)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceGetDefaultLogLevelRequest {
    #[doc = "< service ID"]
    pub service_id: u32,
}
#[test]
fn bindgen_test_layout_DltServiceGetDefaultLogLevelRequest() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceGetDefaultLogLevelRequest> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceGetDefaultLogLevelRequest>(),
        4usize,
        concat!("Size of: ", stringify!(DltServiceGetDefaultLogLevelRequest))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceGetDefaultLogLevelRequest>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DltServiceGetDefaultLogLevelRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetDefaultLogLevelRequest),
            "::",
            stringify!(service_id)
        )
    );
}
#[doc = " The structure of the DLT Service Get Log Info response."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ContextIDsInfoType {
    pub context_id: [::std::os::raw::c_char; 4usize],
    pub log_level: i16,
    pub trace_status: i16,
    pub len_context_description: u16,
    pub context_description: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ContextIDsInfoType() {
    const UNINIT: ::std::mem::MaybeUninit<ContextIDsInfoType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ContextIDsInfoType>(),
        24usize,
        concat!("Size of: ", stringify!(ContextIDsInfoType))
    );
    assert_eq!(
        ::std::mem::align_of::<ContextIDsInfoType>(),
        8usize,
        concat!("Alignment of ", stringify!(ContextIDsInfoType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ContextIDsInfoType),
            "::",
            stringify!(context_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ContextIDsInfoType),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_status) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ContextIDsInfoType),
            "::",
            stringify!(trace_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len_context_description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ContextIDsInfoType),
            "::",
            stringify!(len_context_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ContextIDsInfoType),
            "::",
            stringify!(context_description)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppIDsType {
    pub app_id: [::std::os::raw::c_char; 4usize],
    pub count_context_ids: u16,
    #[doc = "< holds info about a specific con id"]
    pub context_id_info: *mut ContextIDsInfoType,
    pub len_app_description: u16,
    pub app_description: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AppIDsType() {
    const UNINIT: ::std::mem::MaybeUninit<AppIDsType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AppIDsType>(),
        32usize,
        concat!("Size of: ", stringify!(AppIDsType))
    );
    assert_eq!(
        ::std::mem::align_of::<AppIDsType>(),
        8usize,
        concat!("Alignment of ", stringify!(AppIDsType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AppIDsType),
            "::",
            stringify!(app_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count_context_ids) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AppIDsType),
            "::",
            stringify!(count_context_ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_id_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AppIDsType),
            "::",
            stringify!(context_id_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len_app_description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AppIDsType),
            "::",
            stringify!(len_app_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_description) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AppIDsType),
            "::",
            stringify!(app_description)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogInfoType {
    pub count_app_ids: u16,
    #[doc = "< holds info about a specific app id"]
    pub app_ids: *mut AppIDsType,
}
#[test]
fn bindgen_test_layout_LogInfoType() {
    const UNINIT: ::std::mem::MaybeUninit<LogInfoType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LogInfoType>(),
        16usize,
        concat!("Size of: ", stringify!(LogInfoType))
    );
    assert_eq!(
        ::std::mem::align_of::<LogInfoType>(),
        8usize,
        concat!("Alignment of ", stringify!(LogInfoType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count_app_ids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LogInfoType),
            "::",
            stringify!(count_app_ids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).app_ids) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LogInfoType),
            "::",
            stringify!(app_ids)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceGetLogInfoResponse {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< type of request"]
    pub status: u8,
    #[doc = "< log info type"]
    pub log_info_type: LogInfoType,
    #[doc = "< communication interface"]
    pub com: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_DltServiceGetLogInfoResponse() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceGetLogInfoResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceGetLogInfoResponse>(),
        32usize,
        concat!("Size of: ", stringify!(DltServiceGetLogInfoResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceGetLogInfoResponse>(),
        8usize,
        concat!("Alignment of ", stringify!(DltServiceGetLogInfoResponse))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetLogInfoResponse),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetLogInfoResponse),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_info_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetLogInfoResponse),
            "::",
            stringify!(log_info_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).com) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetLogInfoResponse),
            "::",
            stringify!(com)
        )
    );
}
#[doc = " The structure of the DLT Service Set Log Level."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceSetLogLevel {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< application id"]
    pub apid: [::std::os::raw::c_char; 4usize],
    #[doc = "< context id"]
    pub ctid: [::std::os::raw::c_char; 4usize],
    #[doc = "< log level to be set"]
    pub log_level: u8,
    #[doc = "< communication interface"]
    pub com: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_DltServiceSetLogLevel() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceSetLogLevel> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceSetLogLevel>(),
        17usize,
        concat!("Size of: ", stringify!(DltServiceSetLogLevel))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceSetLogLevel>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceSetLogLevel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetLogLevel),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetLogLevel),
            "::",
            stringify!(apid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetLogLevel),
            "::",
            stringify!(ctid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetLogLevel),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).com) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetLogLevel),
            "::",
            stringify!(com)
        )
    );
}
#[doc = " The structure of the DLT Service Set Default Log Level."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceSetDefaultLogLevel {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< default log level to be set"]
    pub log_level: u8,
    #[doc = "< communication interface"]
    pub com: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_DltServiceSetDefaultLogLevel() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceSetDefaultLogLevel> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceSetDefaultLogLevel>(),
        9usize,
        concat!("Size of: ", stringify!(DltServiceSetDefaultLogLevel))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceSetDefaultLogLevel>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceSetDefaultLogLevel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetDefaultLogLevel),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetDefaultLogLevel),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).com) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetDefaultLogLevel),
            "::",
            stringify!(com)
        )
    );
}
#[doc = " The structure of the DLT Service Set Verbose Mode"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceSetVerboseMode {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< new status to be set"]
    pub new_status: u8,
}
#[test]
fn bindgen_test_layout_DltServiceSetVerboseMode() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceSetVerboseMode> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceSetVerboseMode>(),
        5usize,
        concat!("Size of: ", stringify!(DltServiceSetVerboseMode))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceSetVerboseMode>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceSetVerboseMode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetVerboseMode),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetVerboseMode),
            "::",
            stringify!(new_status)
        )
    );
}
#[doc = " The structure of the DLT Service Set Communication Interface Status"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceSetCommunicationInterfaceStatus {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< communication interface"]
    pub com: [::std::os::raw::c_char; 4usize],
    #[doc = "< new status to be set"]
    pub new_status: u8,
}
#[test]
fn bindgen_test_layout_DltServiceSetCommunicationInterfaceStatus() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceSetCommunicationInterfaceStatus> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceSetCommunicationInterfaceStatus>(),
        9usize,
        concat!(
            "Size of: ",
            stringify!(DltServiceSetCommunicationInterfaceStatus)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceSetCommunicationInterfaceStatus>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DltServiceSetCommunicationInterfaceStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetCommunicationInterfaceStatus),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).com) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetCommunicationInterfaceStatus),
            "::",
            stringify!(com)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetCommunicationInterfaceStatus),
            "::",
            stringify!(new_status)
        )
    );
}
#[doc = " The structure of the DLT Service Set Communication Maximum Bandwidth"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceSetCommunicationMaximumBandwidth {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< communication interface"]
    pub com: [::std::os::raw::c_char; 4usize],
    #[doc = "< maximum bandwith"]
    pub max_bandwidth: u32,
}
#[test]
fn bindgen_test_layout_DltServiceSetCommunicationMaximumBandwidth() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceSetCommunicationMaximumBandwidth> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceSetCommunicationMaximumBandwidth>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(DltServiceSetCommunicationMaximumBandwidth)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceSetCommunicationMaximumBandwidth>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DltServiceSetCommunicationMaximumBandwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetCommunicationMaximumBandwidth),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).com) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetCommunicationMaximumBandwidth),
            "::",
            stringify!(com)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_bandwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceSetCommunicationMaximumBandwidth),
            "::",
            stringify!(max_bandwidth)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceResponse {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< reponse status"]
    pub status: u8,
}
#[test]
fn bindgen_test_layout_DltServiceResponse() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceResponse> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceResponse>(),
        5usize,
        concat!("Size of: ", stringify!(DltServiceResponse))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceResponse>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceResponse))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceResponse),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceResponse),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceGetDefaultLogLevelResponse {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< reponse status"]
    pub status: u8,
    #[doc = "< log level"]
    pub log_level: u8,
}
#[test]
fn bindgen_test_layout_DltServiceGetDefaultLogLevelResponse() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceGetDefaultLogLevelResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceGetDefaultLogLevelResponse>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(DltServiceGetDefaultLogLevelResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceGetDefaultLogLevelResponse>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DltServiceGetDefaultLogLevelResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetDefaultLogLevelResponse),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetDefaultLogLevelResponse),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetDefaultLogLevelResponse),
            "::",
            stringify!(log_level)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceMessageBufferOverflowResponse {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< reponse status"]
    pub status: u8,
    #[doc = "< overflow status"]
    pub overflow: u8,
    #[doc = "< overflow counter"]
    pub overflow_counter: u32,
}
#[test]
fn bindgen_test_layout_DltServiceMessageBufferOverflowResponse() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceMessageBufferOverflowResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceMessageBufferOverflowResponse>(),
        10usize,
        concat!(
            "Size of: ",
            stringify!(DltServiceMessageBufferOverflowResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceMessageBufferOverflowResponse>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DltServiceMessageBufferOverflowResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceMessageBufferOverflowResponse),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceMessageBufferOverflowResponse),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceMessageBufferOverflowResponse),
            "::",
            stringify!(overflow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_counter) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceMessageBufferOverflowResponse),
            "::",
            stringify!(overflow_counter)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceGetSoftwareVersion {
    #[doc = "< service ID"]
    pub service_id: u32,
}
#[test]
fn bindgen_test_layout_DltServiceGetSoftwareVersion() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceGetSoftwareVersion> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceGetSoftwareVersion>(),
        4usize,
        concat!("Size of: ", stringify!(DltServiceGetSoftwareVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceGetSoftwareVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceGetSoftwareVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetSoftwareVersion),
            "::",
            stringify!(service_id)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceGetSoftwareVersionResponse {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< reponse status"]
    pub status: u8,
    #[doc = "< length of following payload"]
    pub length: u32,
    #[doc = "< payload"]
    pub payload: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_DltServiceGetSoftwareVersionResponse() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceGetSoftwareVersionResponse> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceGetSoftwareVersionResponse>(),
        17usize,
        concat!(
            "Size of: ",
            stringify!(DltServiceGetSoftwareVersionResponse)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceGetSoftwareVersionResponse>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DltServiceGetSoftwareVersionResponse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetSoftwareVersionResponse),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetSoftwareVersionResponse),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetSoftwareVersionResponse),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceGetSoftwareVersionResponse),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = " The structure of the DLT Service Unregister Context."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceUnregisterContext {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< reponse status"]
    pub status: u8,
    #[doc = "< application id"]
    pub apid: [::std::os::raw::c_char; 4usize],
    #[doc = "< context id"]
    pub ctid: [::std::os::raw::c_char; 4usize],
    #[doc = "< communication interface"]
    pub comid: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_DltServiceUnregisterContext() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceUnregisterContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceUnregisterContext>(),
        17usize,
        concat!("Size of: ", stringify!(DltServiceUnregisterContext))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceUnregisterContext>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceUnregisterContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceUnregisterContext),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceUnregisterContext),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apid) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceUnregisterContext),
            "::",
            stringify!(apid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctid) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceUnregisterContext),
            "::",
            stringify!(ctid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comid) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceUnregisterContext),
            "::",
            stringify!(comid)
        )
    );
}
#[doc = " The structure of the DLT Service Connection Info"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceConnectionInfo {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< reponse status"]
    pub status: u8,
    #[doc = "< new state"]
    pub state: u8,
    #[doc = "< communication interface"]
    pub comid: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_DltServiceConnectionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceConnectionInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceConnectionInfo>(),
        10usize,
        concat!("Size of: ", stringify!(DltServiceConnectionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceConnectionInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceConnectionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceConnectionInfo),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceConnectionInfo),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceConnectionInfo),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comid) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceConnectionInfo),
            "::",
            stringify!(comid)
        )
    );
}
#[doc = " The structure of the DLT Service Timezone"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceTimezone {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< reponse status"]
    pub status: u8,
    #[doc = "< Timezone in seconds"]
    pub timezone: i32,
    #[doc = "< Is daylight saving time"]
    pub isdst: u8,
}
#[test]
fn bindgen_test_layout_DltServiceTimezone() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceTimezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceTimezone>(),
        10usize,
        concat!("Size of: ", stringify!(DltServiceTimezone))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceTimezone>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceTimezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceTimezone),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceTimezone),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timezone) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceTimezone),
            "::",
            stringify!(timezone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isdst) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceTimezone),
            "::",
            stringify!(isdst)
        )
    );
}
#[doc = " The structure of the DLT Service Marker"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceMarker {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< reponse status"]
    pub status: u8,
}
#[test]
fn bindgen_test_layout_DltServiceMarker() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceMarker> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceMarker>(),
        5usize,
        concat!("Size of: ", stringify!(DltServiceMarker))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceMarker>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceMarker))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceMarker),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceMarker),
            "::",
            stringify!(status)
        )
    );
}
#[doc = " The structure of the DLT Service Offline Logstorage"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServiceOfflineLogstorage {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< storage device mount point"]
    pub mount_point: [::std::os::raw::c_char; 1024usize],
    #[doc = "< connection status of the connected device connected/disconnected"]
    pub connection_type: u8,
    #[doc = "< communication interface"]
    pub comid: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_DltServiceOfflineLogstorage() {
    const UNINIT: ::std::mem::MaybeUninit<DltServiceOfflineLogstorage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServiceOfflineLogstorage>(),
        1033usize,
        concat!("Size of: ", stringify!(DltServiceOfflineLogstorage))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServiceOfflineLogstorage>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServiceOfflineLogstorage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceOfflineLogstorage),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_point) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceOfflineLogstorage),
            "::",
            stringify!(mount_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_type) as usize - ptr as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceOfflineLogstorage),
            "::",
            stringify!(connection_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comid) as usize - ptr as usize },
        1029usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServiceOfflineLogstorage),
            "::",
            stringify!(comid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServicePassiveNodeConnect {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< connect/disconnect"]
    pub connection_status: u32,
    #[doc = "< passive node ID"]
    pub node_id: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_DltServicePassiveNodeConnect() {
    const UNINIT: ::std::mem::MaybeUninit<DltServicePassiveNodeConnect> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServicePassiveNodeConnect>(),
        12usize,
        concat!("Size of: ", stringify!(DltServicePassiveNodeConnect))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServicePassiveNodeConnect>(),
        1usize,
        concat!("Alignment of ", stringify!(DltServicePassiveNodeConnect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServicePassiveNodeConnect),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServicePassiveNodeConnect),
            "::",
            stringify!(connection_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServicePassiveNodeConnect),
            "::",
            stringify!(node_id)
        )
    );
}
#[doc = " The structure of DLT Service Passive Node Connection Status"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DltServicePassiveNodeConnectionInfo {
    #[doc = "< service ID"]
    pub service_id: u32,
    #[doc = "< response status"]
    pub status: u8,
    #[doc = "< number of connections"]
    pub num_connections: u32,
    #[doc = "< list of connection status"]
    pub connection_status: [u8; 100usize],
    #[doc = "< list of passive node IDs"]
    pub node_id: [::std::os::raw::c_char; 100usize],
}
#[test]
fn bindgen_test_layout_DltServicePassiveNodeConnectionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<DltServicePassiveNodeConnectionInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltServicePassiveNodeConnectionInfo>(),
        209usize,
        concat!("Size of: ", stringify!(DltServicePassiveNodeConnectionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<DltServicePassiveNodeConnectionInfo>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DltServicePassiveNodeConnectionInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServicePassiveNodeConnectionInfo),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServicePassiveNodeConnectionInfo),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_connections) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServicePassiveNodeConnectionInfo),
            "::",
            stringify!(num_connections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_status) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServicePassiveNodeConnectionInfo),
            "::",
            stringify!(connection_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node_id) as usize - ptr as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(DltServicePassiveNodeConnectionInfo),
            "::",
            stringify!(node_id)
        )
    );
}
#[doc = " Structure to store filter parameters.\n ID are maximal four characters. Unused values are filled with zeros.\n If every value as filter is valid, the id should be empty by having only zero values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltFilter {
    #[doc = "< application id"]
    pub apid: [[::std::os::raw::c_char; 4usize]; 30usize],
    #[doc = "< context id"]
    pub ctid: [[::std::os::raw::c_char; 4usize]; 30usize],
    #[doc = "< log level"]
    pub log_level: [::std::os::raw::c_int; 30usize],
    #[doc = "< upper border for payload"]
    pub payload_max: [i32; 30usize],
    #[doc = "< lower border for payload"]
    pub payload_min: [i32; 30usize],
    #[doc = "< number of filters"]
    pub counter: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DltFilter() {
    const UNINIT: ::std::mem::MaybeUninit<DltFilter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltFilter>(),
        604usize,
        concat!("Size of: ", stringify!(DltFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<DltFilter>(),
        4usize,
        concat!("Alignment of ", stringify!(DltFilter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltFilter),
            "::",
            stringify!(apid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctid) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(DltFilter),
            "::",
            stringify!(ctid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(DltFilter),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload_max) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(DltFilter),
            "::",
            stringify!(payload_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload_min) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(DltFilter),
            "::",
            stringify!(payload_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(DltFilter),
            "::",
            stringify!(counter)
        )
    );
}
#[doc = " The structure to organise the access to DLT files.\n This structure is used by the corresponding functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sDltFile {
    #[doc = "< file handle of opened DLT file"]
    pub handle: *mut FILE,
    #[doc = "< file positions of all DLT messages for fast access to file, only filtered messages"]
    pub index: *mut ::std::os::raw::c_long,
    #[doc = "< number of messages in DLT file with filter"]
    pub counter: i32,
    #[doc = "< number of messages in DLT file without filter"]
    pub counter_total: i32,
    #[doc = "< current index to message parsed in DLT file starting at 0"]
    pub position: i32,
    #[doc = "< length of the file"]
    pub file_length: u64,
    #[doc = "< current position in the file"]
    pub file_position: u64,
    #[doc = "< number of incomplete DLT messages found during file parsing"]
    pub error_messages: i32,
    #[doc = "< pointer to filter list. Zero if no filter is set."]
    pub filter: *mut DltFilter,
    #[doc = "< number of filter set"]
    pub filter_counter: i32,
    #[doc = "< pointer to message"]
    pub msg: DltMessage,
}
#[test]
fn bindgen_test_layout_sDltFile() {
    const UNINIT: ::std::mem::MaybeUninit<sDltFile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sDltFile>(),
        192usize,
        concat!("Size of: ", stringify!(sDltFile))
    );
    assert_eq!(
        ::std::mem::align_of::<sDltFile>(),
        8usize,
        concat!("Alignment of ", stringify!(sDltFile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter_total) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(counter_total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(file_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file_position) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(file_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_messages) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(error_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_counter) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(filter_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sDltFile),
            "::",
            stringify!(msg)
        )
    );
}
#[doc = " The structure to organise the access to DLT files.\n This structure is used by the corresponding functions."]
pub type DltFile = sDltFile;
#[doc = " The structure is used to organise the receiving of data\n including buffer handling.\n This structure is used by the corresponding functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltReceiver {
    #[doc = "< bytes received in last receive call"]
    pub lastBytesRcvd: i32,
    #[doc = "< received bytes"]
    pub bytesRcvd: i32,
    #[doc = "< total number of received bytes"]
    pub totalBytesRcvd: i32,
    #[doc = "< pointer to receiver buffer"]
    pub buffer: *mut ::std::os::raw::c_char,
    #[doc = "< pointer to position within receiver buffer"]
    pub buf: *mut ::std::os::raw::c_char,
    pub backup_buf: *mut ::std::os::raw::c_char,
    #[doc = "< connection handle"]
    pub fd: ::std::os::raw::c_int,
    #[doc = "< type of connection handle"]
    pub type_: DltReceiverType,
    #[doc = "< size of receiver buffer"]
    pub buffersize: i32,
    #[doc = "< socket address information"]
    pub addr: sockaddr_in,
}
#[test]
fn bindgen_test_layout_DltReceiver() {
    const UNINIT: ::std::mem::MaybeUninit<DltReceiver> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltReceiver>(),
        72usize,
        concat!("Size of: ", stringify!(DltReceiver))
    );
    assert_eq!(
        ::std::mem::align_of::<DltReceiver>(),
        8usize,
        concat!("Alignment of ", stringify!(DltReceiver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastBytesRcvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltReceiver),
            "::",
            stringify!(lastBytesRcvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesRcvd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltReceiver),
            "::",
            stringify!(bytesRcvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalBytesRcvd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltReceiver),
            "::",
            stringify!(totalBytesRcvd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DltReceiver),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DltReceiver),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backup_buf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DltReceiver),
            "::",
            stringify!(backup_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DltReceiver),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DltReceiver),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffersize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DltReceiver),
            "::",
            stringify!(buffersize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DltReceiver),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltBuffer {
    pub shm: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_uint,
    pub mem: *mut ::std::os::raw::c_uchar,
    #[doc = "< Minimum size of buffer"]
    pub min_size: u32,
    #[doc = "< Maximum size of buffer"]
    pub max_size: u32,
    #[doc = "< Step size of buffer"]
    pub step_size: u32,
}
#[test]
fn bindgen_test_layout_DltBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<DltBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(DltBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<DltBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(DltBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBuffer),
            "::",
            stringify!(shm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBuffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBuffer),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBuffer),
            "::",
            stringify!(min_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBuffer),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBuffer),
            "::",
            stringify!(step_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltBufferHead {
    pub write: ::std::os::raw::c_int,
    pub read: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DltBufferHead() {
    const UNINIT: ::std::mem::MaybeUninit<DltBufferHead> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltBufferHead>(),
        12usize,
        concat!("Size of: ", stringify!(DltBufferHead))
    );
    assert_eq!(
        ::std::mem::align_of::<DltBufferHead>(),
        4usize,
        concat!("Alignment of ", stringify!(DltBufferHead))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBufferHead),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBufferHead),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBufferHead),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltBufferBlockHead {
    pub head: [::std::os::raw::c_char; 4usize],
    pub status: ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DltBufferBlockHead() {
    const UNINIT: ::std::mem::MaybeUninit<DltBufferBlockHead> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltBufferBlockHead>(),
        12usize,
        concat!("Size of: ", stringify!(DltBufferBlockHead))
    );
    assert_eq!(
        ::std::mem::align_of::<DltBufferBlockHead>(),
        4usize,
        concat!("Alignment of ", stringify!(DltBufferBlockHead))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBufferBlockHead),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBufferBlockHead),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBufferBlockHead),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltBindAddress {
    pub ip: [::std::os::raw::c_char; 16usize],
    pub next: *mut DltBindAddress,
}
#[test]
fn bindgen_test_layout_DltBindAddress() {
    const UNINIT: ::std::mem::MaybeUninit<DltBindAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltBindAddress>(),
        24usize,
        concat!("Size of: ", stringify!(DltBindAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<DltBindAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(DltBindAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBindAddress),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DltBindAddress),
            "::",
            stringify!(next)
        )
    );
}
pub type DltBindAddress_t = DltBindAddress;
extern "C" {
    #[doc = " Helper function to print a byte array in hex.\n @param ptr pointer to the byte array.\n @param size number of bytes to be printed."]
    pub fn dlt_print_hex(ptr: *mut u8, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Helper function to print a byte array in hex into a string.\n @param text pointer to a ASCII string, in which the text is written\n @param textlength maximal size of text buffer\n @param ptr pointer to the byte array.\n @param size number of bytes to be printed.\n @return negative value if there was an error"]
    pub fn dlt_print_hex_string(
        text: *mut ::std::os::raw::c_char,
        textlength: ::std::os::raw::c_int,
        ptr: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Helper function to print a byte array in hex and ascii into a string.\n @param text pointer to a ASCII string, in which the text is written\n @param textlength maximal size of text buffer\n @param ptr pointer to the byte array.\n @param size number of bytes to be printed.\n @param html output is html? 0 - false, 1 - true\n @return negative value if there was an error"]
    pub fn dlt_print_mixed_string(
        text: *mut ::std::os::raw::c_char,
        textlength: ::std::os::raw::c_int,
        ptr: *mut u8,
        size: ::std::os::raw::c_int,
        html: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Helper function to print a byte array in ascii into a string.\n @param text pointer to a ASCII string, in which the text is written\n @param textlength maximal size of text buffer\n @param ptr pointer to the byte array.\n @param size number of bytes to be printed.\n @return negative value if there was an error"]
    pub fn dlt_print_char_string(
        text: *mut *mut ::std::os::raw::c_char,
        textlength: ::std::os::raw::c_int,
        ptr: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Helper function to determine a bounded length of a string.\n This function returns zero if @a str is a null pointer,\n and it returns @a maxsize if the null character was not found in the first @a maxsize bytes of @a str.\n This is a re-implementation of C11's strnlen_s, which we cannot yet assume to be available.\n @param str pointer to string whose length is to be determined\n @param maxsize maximal considered length of @a str\n @return the bounded length of the string"]
    pub fn dlt_strnlen_s(str_: *const ::std::os::raw::c_char, maxsize: usize) -> usize;
}
extern "C" {
    #[doc = " Helper function to print an id.\n @param text pointer to ASCII string where to write the id\n @param id four byte char array as used in DLT mesages as IDs."]
    pub fn dlt_print_id(text: *mut ::std::os::raw::c_char, id: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Helper function to set an ID parameter.\n @param id four byte char array as used in DLT mesages as IDs.\n @param text string to be copied into char array."]
    pub fn dlt_set_id(id: *mut ::std::os::raw::c_char, text: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Helper function to remove not nice to print characters, e.g. NULL or carage return.\n @param text pointer to string to be cleaned.\n @param length length of string excluding terminating zero."]
    pub fn dlt_clean_string(text: *mut ::std::os::raw::c_char, length: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Initialise the filter list.\n This function must be called before using further dlt filter.\n @param filter pointer to structure of organising DLT filter\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_filter_init(
        filter: *mut DltFilter,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Free the used memory by the organising structure of filter.\n @param filter pointer to structure of organising DLT filter\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_filter_free(
        filter: *mut DltFilter,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Load filter list from file.\n @param filter pointer to structure of organising DLT filter\n @param filename filename to load filters from\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_filter_load(
        filter: *mut DltFilter,
        filename: *const ::std::os::raw::c_char,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Save filter in space separated list to text file.\n @param filter pointer to structure of organising DLT filter\n @param filename filename to safe filters into\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_filter_save(
        filter: *mut DltFilter,
        filename: *const ::std::os::raw::c_char,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Find index of filter in filter list\n @param filter pointer to structure of organising DLT filter\n @param apid application id to be found in filter list\n @param ctid context id to be found in filter list\n @param log_level log level to be found in filter list\n @param payload_min minimum payload lenght to be found in filter list\n @param payload_max maximum payload lenght to be found in filter list\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error (or not found), else return index of filter"]
    pub fn dlt_filter_find(
        filter: *mut DltFilter,
        apid: *const ::std::os::raw::c_char,
        ctid: *const ::std::os::raw::c_char,
        log_level: ::std::os::raw::c_int,
        payload_min: i32,
        payload_max: i32,
        verbose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add new filter to filter list.\n @param filter pointer to structure of organising DLT filter\n @param apid application id to be added to filter list (must always be set).\n @param ctid context id to be added to filter list. empty equals don't care.\n @param log_level log level to be added to filter list. 0 equals don't care.\n @param payload_min min lenght of payload to be added to filter list. 0 equals don't care.\n @param payload_max max lenght of payload to be added to filter list. INT32_MAX equals don't care.\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_filter_add(
        filter: *mut DltFilter,
        apid: *const ::std::os::raw::c_char,
        ctid: *const ::std::os::raw::c_char,
        log_level: ::std::os::raw::c_int,
        payload_min: i32,
        payload_max: i32,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Delete filter from filter list\n @param filter pointer to structure of organising DLT filter\n @param apid application id to be deleted from filter list\n @param ctid context id to be deleted from filter list\n @param log_level log level to be deleted from filter list\n @param payload_min minimum payload lenght to be deleted from filter list\n @param payload_max maximum payload lenght to be deleted from filter list\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_filter_delete(
        filter: *mut DltFilter,
        apid: *const ::std::os::raw::c_char,
        ctid: *const ::std::os::raw::c_char,
        log_level: ::std::os::raw::c_int,
        payload_min: i32,
        payload_max: i32,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialise the structure used to access a DLT message.\n This function must be called before using further dlt_message functions.\n @param msg pointer to structure of organising access to DLT messages\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_init(msg: *mut DltMessage, verbose: ::std::os::raw::c_int)
        -> DltReturnValue;
}
extern "C" {
    #[doc = " Free the used memory by the organising structure of file.\n @param msg pointer to structure of organising access to DLT messages\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_free(msg: *mut DltMessage, verbose: ::std::os::raw::c_int)
        -> DltReturnValue;
}
extern "C" {
    #[doc = " Print Header into an ASCII string.\n This function calls dlt_message_header_flags() with flags=DLT_HEADER_SHOW_ALL\n @param msg pointer to structure of organising access to DLT messages\n @param text pointer to a ASCII string, in which the header is written\n @param textlength maximal size of text buffer\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_header(
        msg: *mut DltMessage,
        text: *mut ::std::os::raw::c_char,
        textlength: usize,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Print Header into an ASCII string, selective.\n @param msg pointer to structure of organising access to DLT messages\n @param text pointer to a ASCII string, in which the header is written\n @param textlength maximal size of text buffer\n @param flags select, bit-field to select, what should be printed (DLT_HEADER_SHOW_...)\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_header_flags(
        msg: *mut DltMessage,
        text: *mut ::std::os::raw::c_char,
        textlength: usize,
        flags: ::std::os::raw::c_int,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Print Payload into an ASCII string.\n @param msg pointer to structure of organising access to DLT messages\n @param text pointer to a ASCII string, in which the header is written\n @param textlength maximal size of text buffer\n @param type 1 = payload as hex, 2 = payload as ASCII.\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_payload(
        msg: *mut DltMessage,
        text: *mut ::std::os::raw::c_char,
        textlength: usize,
        type_: ::std::os::raw::c_int,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Check if message is filtered or not. All filters are applied (logical OR).\n @param msg pointer to structure of organising access to DLT messages\n @param filter pointer to filter\n @param verbose if set to true verbose information is printed out.\n @return 1 = filter matches, 0 = filter does not match, negative value if there was an error"]
    pub fn dlt_message_filter_check(
        msg: *mut DltMessage,
        filter: *mut DltFilter,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Read message from memory buffer.\n Message in buffer has no storage header.\n @param msg pointer to structure of organising access to DLT messages\n @param buffer pointer to memory buffer\n @param length length of message in buffer\n @param resync if set to true resync to serial header is enforced\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_read(
        msg: *mut DltMessage,
        buffer: *mut u8,
        length: ::std::os::raw::c_uint,
        resync: ::std::os::raw::c_int,
        verbose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get standard header extra parameters\n @param msg pointer to structure of organising access to DLT messages\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_get_extraparameters(
        msg: *mut DltMessage,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Set standard header extra parameters\n @param msg pointer to structure of organising access to DLT messages\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_set_extraparameters(
        msg: *mut DltMessage,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialise the structure used to access a DLT file.\n This function must be called before using further dlt_file functions.\n @param file pointer to structure of organising access to DLT file\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_file_init(file: *mut DltFile, verbose: ::std::os::raw::c_int) -> DltReturnValue;
}
extern "C" {
    #[doc = " Set a list to filters.\n This function should be called before loading a DLT file, if filters should be used.\n A filter list is an array of filters. Several filters are combined logically by or operation.\n The filter list is not copied, so take care to keep list in memory.\n @param file pointer to structure of organising access to DLT file\n @param filter pointer to filter list array\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_file_set_filter(
        file: *mut DltFile,
        filter: *mut DltFilter,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialising loading a DLT file.\n @param file pointer to structure of organising access to DLT file\n @param filename filename of DLT file\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_file_open(
        file: *mut DltFile,
        filename: *const ::std::os::raw::c_char,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " This function reads DLT file and parse DLT message one by one.\n Each message will be written into new file.\n If a filter is set, the filter list is used.\n @param file pointer to structure of organizing access to DLT file\n @param filename file to contain parsed DLT messages.\n @param type 1 = payload as hex, 2 = payload as ASCII.\n @param verbose if set to true verbose information is printed out.\n @return 0 = message does not match filter, 1 = message was read, negative value if there was an error"]
    pub fn dlt_file_quick_parsing(
        file: *mut DltFile,
        filename: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Find next message in the DLT file and parse them.\n This function finds the next message in the DLT file.\n If a filter is set, the filter list is used.\n @param file pointer to structure of organising access to DLT file\n @param verbose if set to true verbose information is printed out.\n @return 0 = message does not match filter, 1 = message was read, negative value if there was an error"]
    pub fn dlt_file_read(file: *mut DltFile, verbose: ::std::os::raw::c_int) -> DltReturnValue;
}
extern "C" {
    #[doc = " Find next message in the DLT file in RAW format (without storage header) and parse them.\n This function finds the next message in the DLT file.\n If a filter is set, the filter list is used.\n @param file pointer to structure of organising access to DLT file\n @param resync Resync to serial header when set to true\n @param verbose if set to true verbose information is printed out.\n @return 0 = message does not match filter, 1 = message was read, negative value if there was an error"]
    pub fn dlt_file_read_raw(
        file: *mut DltFile,
        resync: ::std::os::raw::c_int,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Closing loading a DLT file.\n @param file pointer to structure of organising access to DLT file\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_file_close(file: *mut DltFile, verbose: ::std::os::raw::c_int) -> DltReturnValue;
}
extern "C" {
    #[doc = " Load standard header of a message from file\n @param file pointer to structure of organising access to DLT file\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_file_read_header(
        file: *mut DltFile,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Load standard header of a message from file in RAW format (without storage header)\n @param file pointer to structure of organising access to DLT file\n @param resync Resync to serial header when set to true\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_file_read_header_raw(
        file: *mut DltFile,
        resync: ::std::os::raw::c_int,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Load, if available in message, extra standard header fields and\n extended header of a message from file\n (dlt_file_read_header() must have been called before this call!)\n @param file pointer to structure of organising access to DLT file\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_file_read_header_extended(
        file: *mut DltFile,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Load payload of a message from file\n (dlt_file_read_header() must have been called before this call!)\n @param file pointer to structure of organising access to DLT file\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_file_read_data(file: *mut DltFile, verbose: ::std::os::raw::c_int)
        -> DltReturnValue;
}
extern "C" {
    #[doc = " Load headers and payload of a message selected by the index.\n If filters are set, index is based on the filtered list.\n @param file pointer to structure of organising access to DLT file\n @param index position of message in the files beginning from zero\n @param verbose if set to true verbose information is printed out.\n @return number of messages loaded, negative value if there was an error"]
    pub fn dlt_file_message(
        file: *mut DltFile,
        index: ::std::os::raw::c_int,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Free the used memory by the organising structure of file.\n @param file pointer to structure of organising access to DLT file\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_file_free(file: *mut DltFile, verbose: ::std::os::raw::c_int) -> DltReturnValue;
}
extern "C" {
    #[doc = " Set internal logging filename if mode 2\n @param filename the filename"]
    pub fn dlt_log_set_filename(filename: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Set internal logging level\n @param level the level"]
    pub fn dlt_log_set_level(level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set whether to print \"name\" and \"unit\" attributes in console output\n @param state  true = with attributes, false = without attributes"]
    pub fn dlt_print_with_attributes(state: bool);
}
extern "C" {
    #[doc = " Initialize (external) logging facility\n @param mode positive, 0 = log to stdout, 1 = log to syslog, 2 = log to file, 3 = log to stderr"]
    pub fn dlt_log_init(mode: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Print with variable arguments to specified file descriptor by DLT_LOG_MODE environment variable (like fprintf)\n @param format format string for message\n @return negative value if there was an error or the total number of characters written is returned on success"]
    pub fn dlt_user_printf(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Log ASCII string with null-termination to (external) logging facility\n @param prio priority (see syslog() call)\n @param s Pointer to ASCII string with null-termination\n @return negative value if there was an error"]
    pub fn dlt_log(prio: ::std::os::raw::c_int, s: *mut ::std::os::raw::c_char) -> DltReturnValue;
}
extern "C" {
    #[doc = " Log with variable arguments to (external) logging facility (like printf)\n @param prio priority (see syslog() call)\n @param format format string for log message\n @return negative value if there was an error"]
    pub fn dlt_vlog(
        prio: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Log size bytes with variable arguments to (external) logging facility (similar to snprintf)\n @param prio priority (see syslog() call)\n @param size number of bytes to log\n @param format format string for log message\n @return negative value if there was an error"]
    pub fn dlt_vnlog(
        prio: ::std::os::raw::c_int,
        size: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " De-Initialize (external) logging facility"]
    pub fn dlt_log_free();
}
extern "C" {
    #[doc = " Initialising a dlt receiver structure\n @param receiver pointer to dlt receiver structure\n @param _fd handle to file/socket/fifo, fram which the data should be received\n @param type specify whether received data is from socket or file/fifo\n @param _buffersize size of data buffer for storing the received data\n @return negative value if there was an error"]
    pub fn dlt_receiver_init(
        receiver: *mut DltReceiver,
        _fd: ::std::os::raw::c_int,
        type_: DltReceiverType,
        _buffersize: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " De-Initialize a dlt receiver structure\n @param receiver pointer to dlt receiver structure\n @return negative value if there was an error"]
    pub fn dlt_receiver_free(receiver: *mut DltReceiver) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialising a dlt receiver structure\n @param receiver pointer to dlt receiver structure\n @param fd handle to file/socket/fifo, fram which the data should be received\n @param type specify whether received data is from socket or file/fifo\n @param buffer data buffer for storing the received data\n @return negative value if there was an error and zero if success"]
    pub fn dlt_receiver_init_global_buffer(
        receiver: *mut DltReceiver,
        fd: ::std::os::raw::c_int,
        type_: DltReceiverType,
        buffer: *mut *mut ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " De-Initialize a dlt receiver structure\n @param receiver pointer to dlt receiver structure\n @return negative value if there was an error and zero if success"]
    pub fn dlt_receiver_free_global_buffer(receiver: *mut DltReceiver) -> DltReturnValue;
}
extern "C" {
    #[doc = " Receive data from socket or file/fifo using the dlt receiver structure\n @param receiver pointer to dlt receiver structure\n @return number of received bytes or negative value if there was an error"]
    pub fn dlt_receiver_receive(receiver: *mut DltReceiver) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a specific size of bytes from the received data\n @param receiver pointer to dlt receiver structure\n @param size amount of bytes to be removed\n @return negative value if there was an error"]
    pub fn dlt_receiver_remove(
        receiver: *mut DltReceiver,
        size: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Move data from last receive call to front of receive buffer\n @param receiver pointer to dlt receiver structure\n @return negative value if there was an error"]
    pub fn dlt_receiver_move_to_begin(receiver: *mut DltReceiver) -> DltReturnValue;
}
extern "C" {
    #[doc = " Check whether to_get amount of data is available in receiver and\n copy it to dest. Skip the DltUserHeader if skip_header is set to 1.\n @param receiver pointer to dlt receiver structure\n @param dest pointer to the destination buffer\n @param to_get size of the data to copy in dest\n @param skip_header whether if the DltUserHeader must be skipped."]
    pub fn dlt_receiver_check_and_get(
        receiver: *mut DltReceiver,
        dest: *mut ::std::os::raw::c_void,
        to_get: ::std::os::raw::c_uint,
        skip_header: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Fill out storage header of a dlt message\n @param storageheader pointer to storage header of a dlt message\n @param ecu name of ecu to be set in storage header\n @return negative value if there was an error"]
    pub fn dlt_set_storageheader(
        storageheader: *mut DltStorageHeader,
        ecu: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Check if a storage header contains its marker\n @param storageheader pointer to storage header of a dlt message\n @return 0 no, 1 yes, negative value if there was an error"]
    pub fn dlt_check_storageheader(storageheader: *mut DltStorageHeader) -> DltReturnValue;
}
extern "C" {
    #[doc = " Checks if received size is big enough for expected data\n @param received size\n @param required size\n @return negative value if required size is not sufficient"]
    pub fn dlt_check_rcv_data_size(
        received: ::std::os::raw::c_int,
        required: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialise static ringbuffer with a size of size.\n Initialise as server. Init counters.\n Memory is already allocated.\n @param buf Pointer to ringbuffer structure\n @param ptr Ptr to ringbuffer memory\n @param size Maximum size of buffer in bytes\n @return negative value if there was an error"]
    pub fn dlt_buffer_init_static_server(
        buf: *mut DltBuffer,
        ptr: *const ::std::os::raw::c_uchar,
        size: u32,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialize static ringbuffer with a size of size.\n Initialise as a client. Do not change counters.\n Memory is already allocated.\n @param buf Pointer to ringbuffer structure\n @param ptr Ptr to ringbuffer memory\n @param size Maximum size of buffer in bytes\n @return negative value if there was an error"]
    pub fn dlt_buffer_init_static_client(
        buf: *mut DltBuffer,
        ptr: *const ::std::os::raw::c_uchar,
        size: u32,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialize dynamic ringbuffer with a size of size.\n Initialise as a client. Do not change counters.\n Memory will be allocated starting with min_size.\n If more memory is needed size is increased wit step_size.\n The maximum size is max_size.\n @param buf Pointer to ringbuffer structure\n @param min_size Minimum size of buffer in bytes\n @param max_size Maximum size of buffer in bytes\n @param step_size size of which ringbuffer is increased\n @return negative value if there was an error"]
    pub fn dlt_buffer_init_dynamic(
        buf: *mut DltBuffer,
        min_size: u32,
        max_size: u32,
        step_size: u32,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Deinitilaise usage of static ringbuffer\n @param buf Pointer to ringbuffer structure\n @return negative value if there was an error"]
    pub fn dlt_buffer_free_static(buf: *mut DltBuffer) -> DltReturnValue;
}
extern "C" {
    #[doc = " Release and free memory used by dynamic ringbuffer\n @param buf Pointer to ringbuffer structure\n @return negative value if there was an error"]
    pub fn dlt_buffer_free_dynamic(buf: *mut DltBuffer) -> DltReturnValue;
}
extern "C" {
    #[doc = " Check if message fits into buffer.\n @param buf Pointer to buffer structure\n @param needed Needed size\n @return DLT_RETURN_OK if enough space, DLT_RETURN_ERROR otherwise"]
    pub fn dlt_buffer_check_size(
        buf: *mut DltBuffer,
        needed: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write one entry to ringbuffer\n @param buf Pointer to ringbuffer structure\n @param data Pointer to data to be written to ringbuffer\n @param size Size of data in bytes to be written to ringbuffer\n @return negative value if there was an error"]
    pub fn dlt_buffer_push(
        buf: *mut DltBuffer,
        data: *const ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_uint,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write up to three entries to ringbuffer.\n Entries are joined to one block.\n @param buf Pointer to ringbuffer structure\n @param data1 Pointer to data to be written to ringbuffer\n @param size1 Size of data in bytes to be written to ringbuffer\n @param data2 Pointer to data to be written to ringbuffer\n @param size2 Size of data in bytes to be written to ringbuffer\n @param data3 Pointer to data to be written to ringbuffer\n @param size3 Size of data in bytes to be written to ringbuffer\n @return negative value if there was an error"]
    pub fn dlt_buffer_push3(
        buf: *mut DltBuffer,
        data1: *const ::std::os::raw::c_uchar,
        size1: ::std::os::raw::c_uint,
        data2: *const ::std::os::raw::c_uchar,
        size2: ::std::os::raw::c_uint,
        data3: *const ::std::os::raw::c_uchar,
        size3: ::std::os::raw::c_uint,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Read one entry from ringbuffer.\n Remove it from ringbuffer.\n @param buf Pointer to ringbuffer structure\n @param data Pointer to data read from ringbuffer\n @param max_size Max size of read data in bytes from ringbuffer\n @return size of read data, zero if no data available, negative value if there was an error"]
    pub fn dlt_buffer_pull(
        buf: *mut DltBuffer,
        data: *mut ::std::os::raw::c_uchar,
        max_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read one entry from ringbuffer.\n Do not remove it from ringbuffer.\n @param buf Pointer to ringbuffer structure\n @param data Pointer to data read from ringbuffer\n @param max_size Max size of read data in bytes from ringbuffer\n @return size of read data, zero if no data available, negative value if there was an error"]
    pub fn dlt_buffer_copy(
        buf: *mut DltBuffer,
        data: *mut ::std::os::raw::c_uchar,
        max_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove entry from ringbuffer.\n @param buf Pointer to ringbuffer structure\n @return size of read data, zero if no data available, negative value if there was an error"]
    pub fn dlt_buffer_remove(buf: *mut DltBuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Print information about buffer and log to internal DLT log.\n @param buf Pointer to ringbuffer structure"]
    pub fn dlt_buffer_info(buf: *mut DltBuffer);
}
extern "C" {
    #[doc = " Print status of buffer and log to internal DLT log.\n @param buf Pointer to ringbuffer structure"]
    pub fn dlt_buffer_status(buf: *mut DltBuffer);
}
extern "C" {
    #[doc = " Get total size in bytes of ringbuffer.\n If buffer is dynamic, max size is returned.\n @param buf Pointer to ringbuffer structure\n @return total size of buffer"]
    pub fn dlt_buffer_get_total_size(buf: *mut DltBuffer) -> u32;
}
extern "C" {
    #[doc = " Get used size in bytes of ringbuffer.\n @param buf Pointer to ringbuffer structure\n @return used size of buffer"]
    pub fn dlt_buffer_get_used_size(buf: *mut DltBuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get number of entries in ringbuffer.\n @param buf Pointer to ringbuffer structure\n @return number of entries"]
    pub fn dlt_buffer_get_message_count(buf: *mut DltBuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function: Setup serial connection\n @param fd File descriptor of serial tty device\n @param speed Serial line speed, as defined in termios.h\n @return negative value if there was an error"]
    pub fn dlt_setup_serial(fd: ::std::os::raw::c_int, speed: speed_t) -> DltReturnValue;
}
extern "C" {
    #[doc = " Helper function: Convert serial line baudrate (as number) to line speed (as defined in termios.h)\n @param baudrate Serial line baudrate (as number)\n @return Serial line speed, as defined in termios.h"]
    pub fn dlt_convert_serial_speed(baudrate: ::std::os::raw::c_int) -> speed_t;
}
extern "C" {
    #[doc = " Print dlt version and dlt svn version to buffer\n @param buf Pointer to buffer\n @param size size of buffer"]
    pub fn dlt_get_version(buf: *mut ::std::os::raw::c_char, size: usize);
}
extern "C" {
    #[doc = " Print dlt major version to buffer\n @param buf Pointer to buffer\n @param size size of buffer"]
    pub fn dlt_get_major_version(buf: *mut ::std::os::raw::c_char, size: usize);
}
extern "C" {
    #[doc = " Print dlt minor version to buffer\n @param buf Pointer to buffer\n @param size size of buffer"]
    pub fn dlt_get_minor_version(buf: *mut ::std::os::raw::c_char, size: usize);
}
extern "C" {
    #[doc = " Common part of initialisation. Evaluates the following environment variables\n and stores them in dlt_user struct:\n - DLT_DISABLE_EXTENDED_HEADER_FOR_NONVERBOSE\n - DLT_LOCAL_PRINT_MODE (AUTOMATIC: 0, FORCE_ON: 2, FORCE_OFF: 3)\n - DLT_INITIAL_LOG_LEVEL (e.g. APPx:CTXa:6;APPx:CTXb:5)\n - DLT_FORCE_BLOCKING\n - DLT_USER_BUFFER_MIN\n - DLT_USER_BUFFER_MAX\n - DLT_USER_BUFFER_STEP\n - DLT_LOG_MSG_BUF_LEN\n - DLT_DISABLE_INJECTION_MSG_AT_USER\n @return negative value if there was an error"]
    pub fn dlt_init_common() -> DltReturnValue;
}
extern "C" {
    #[doc = " Return the uptime of the system in 0.1 ms resolution\n @return 0 if there was an error"]
    pub fn dlt_uptime() -> u32;
}
extern "C" {
    #[doc = " Print header of a DLT message\n @param message pointer to structure of organising access to DLT messages\n @param text pointer to a ASCII string, in which the header is written\n @param size maximal size of text buffer\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_print_header(
        message: *mut DltMessage,
        text: *mut ::std::os::raw::c_char,
        size: u32,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Print payload of a DLT message as Hex-Output\n @param message pointer to structure of organising access to DLT messages\n @param text pointer to a ASCII string, in which the output is written\n @param size maximal size of text buffer\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_print_hex(
        message: *mut DltMessage,
        text: *mut ::std::os::raw::c_char,
        size: u32,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Print payload of a DLT message as ASCII-Output\n @param message pointer to structure of organising access to DLT messages\n @param text pointer to a ASCII string, in which the output is written\n @param size maximal size of text buffer\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_print_ascii(
        message: *mut DltMessage,
        text: *mut ::std::os::raw::c_char,
        size: u32,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Print payload of a DLT message as Mixed-Ouput (Hex and ASCII), for plain text output\n @param message pointer to structure of organising access to DLT messages\n @param text pointer to a ASCII string, in which the output is written\n @param size maximal size of text buffer\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_print_mixed_plain(
        message: *mut DltMessage,
        text: *mut ::std::os::raw::c_char,
        size: u32,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Print payload of a DLT message as Mixed-Ouput (Hex and ASCII), for HTML text output\n @param message pointer to structure of organising access to DLT messages\n @param text pointer to a ASCII string, in which the output is written\n @param size maximal size of text buffer\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_print_mixed_html(
        message: *mut DltMessage,
        text: *mut ::std::os::raw::c_char,
        size: u32,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Decode and print a argument of a DLT message\n @param msg pointer to structure of organising access to DLT messages\n @param type_info Type of argument\n @param ptr pointer to pointer to data (pointer to data is changed within this function)\n @param datalength pointer to datalength (datalength is changed within this function)\n @param text pointer to a ASCII string, in which the output is written\n @param textlength maximal size of text buffer\n @param byteLength If argument is a string, and this value is 0 or greater, this value will be taken as string length\n @param verbose if set to true verbose information is printed out.\n @return negative value if there was an error"]
    pub fn dlt_message_argument_print(
        msg: *mut DltMessage,
        type_info: u32,
        ptr: *mut *mut u8,
        datalength: *mut i32,
        text: *mut ::std::os::raw::c_char,
        textlength: usize,
        byteLength: ::std::os::raw::c_int,
        verbose: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Check environment variables."]
    pub fn dlt_check_envvar();
}
extern "C" {
    #[doc = " Parse the response text and identifying service id and its options.\n\n @param resp_text   char *\n @param service_id  int *\n @param service_opt int *\n @return pointer to resp_text"]
    pub fn dlt_set_loginfo_parse_service_id(
        resp_text: *mut ::std::os::raw::c_char,
        service_id: *mut u32,
        service_opt: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert get log info from ASCII to uint16\n\n @param rp        char\n @param rp_count  int\n @return length"]
    pub fn dlt_getloginfo_conv_ascii_to_uint16_t(
        rp: *mut ::std::os::raw::c_char,
        rp_count: *mut ::std::os::raw::c_int,
    ) -> i16;
}
extern "C" {
    #[doc = " Convert get log info from ASCII to int16\n\n @param rp        char\n @param rp_count  int\n @return length"]
    pub fn dlt_getloginfo_conv_ascii_to_int16_t(
        rp: *mut ::std::os::raw::c_char,
        rp_count: *mut ::std::os::raw::c_int,
    ) -> i16;
}
extern "C" {
    #[doc = " Convert get log info from ASCII to ID\n\n @param rp        char\n @param rp_count  int\n @param wp        char\n @param len       int"]
    pub fn dlt_getloginfo_conv_ascii_to_id(
        rp: *mut ::std::os::raw::c_char,
        rp_count: *mut ::std::os::raw::c_int,
        wp: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Convert from hex ASCII to binary\n @param ptr    const char\n @param binary uint8_t\n @param size   int"]
    pub fn dlt_hex_ascii_to_binary(
        ptr: *const ::std::os::raw::c_char,
        binary: *mut u8,
        size: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Helper function to execute the execvp function in a new child process.\n @param filename file path to store the stdout of command (NULL if not required)\n @param command execution command followed by arguments with NULL-termination\n @return negative value if there was an error"]
    pub fn dlt_execute_command(
        filename: *mut ::std::os::raw::c_char,
        command: *mut ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    const UNINIT: ::std::mem::MaybeUninit<flock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    const UNINIT: ::std::mem::MaybeUninit<stat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_atim) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_mtim) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).st_ctim) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    pub fn fcntl(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open(
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fallocate(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._attribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._tid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigev_thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigev_un) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub type mqd_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mq_attr {
    pub mq_flags: __syscall_slong_t,
    pub mq_maxmsg: __syscall_slong_t,
    pub mq_msgsize: __syscall_slong_t,
    pub mq_curmsgs: __syscall_slong_t,
    pub __pad: [__syscall_slong_t; 4usize],
}
#[test]
fn bindgen_test_layout_mq_attr() {
    const UNINIT: ::std::mem::MaybeUninit<mq_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mq_attr>(),
        64usize,
        concat!("Size of: ", stringify!(mq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<mq_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(mq_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mq_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mq_attr),
            "::",
            stringify!(mq_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mq_maxmsg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mq_attr),
            "::",
            stringify!(mq_maxmsg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mq_msgsize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mq_attr),
            "::",
            stringify!(mq_msgsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mq_curmsgs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mq_attr),
            "::",
            stringify!(mq_curmsgs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mq_attr),
            "::",
            stringify!(__pad)
        )
    );
}
extern "C" {
    pub fn mq_open(
        __name: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> mqd_t;
}
extern "C" {
    pub fn mq_close(__mqdes: mqd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mq_getattr(__mqdes: mqd_t, __mqstat: *mut mq_attr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mq_setattr(
        __mqdes: mqd_t,
        __mqstat: *const mq_attr,
        __omqstat: *mut mq_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mq_unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mq_notify(__mqdes: mqd_t, __notification: *const sigevent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mq_receive(
        __mqdes: mqd_t,
        __msg_ptr: *mut ::std::os::raw::c_char,
        __msg_len: usize,
        __msg_prio: *mut ::std::os::raw::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn mq_send(
        __mqdes: mqd_t,
        __msg_ptr: *const ::std::os::raw::c_char,
        __msg_len: usize,
        __msg_prio: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mq_timedreceive(
        __mqdes: mqd_t,
        __msg_ptr: *mut ::std::os::raw::c_char,
        __msg_len: usize,
        __msg_prio: *mut ::std::os::raw::c_uint,
        __abs_timeout: *const timespec,
    ) -> isize;
}
extern "C" {
    pub fn mq_timedsend(
        __mqdes: mqd_t,
        __msg_ptr: *const ::std::os::raw::c_char,
        __msg_len: usize,
        __msg_prio: ::std::os::raw::c_uint,
        __abs_timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_11 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_12 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_12 = 0;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_13 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_14 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_14 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_15 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_15 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_15 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_15 = 0;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_16 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_16 = 1;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_17 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_17 = 1;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_18 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_18 = 1;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_19 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_20 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_sem_t() {
    const UNINIT: ::std::mem::MaybeUninit<sem_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sem_t>(),
        32usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sem_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn sem_init(
        __sem: *mut sem_t,
        __pshared: ::std::os::raw::c_int,
        __value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_destroy(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_open(
        __name: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> *mut sem_t;
}
extern "C" {
    pub fn sem_close(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_wait(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_trywait(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_post(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_getvalue(
        __sem: *mut sem_t,
        __sval: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltShm {
    pub shmfd: ::std::os::raw::c_int,
    pub sem: *mut sem_t,
    pub buffer: DltBuffer,
}
#[test]
fn bindgen_test_layout_DltShm() {
    const UNINIT: ::std::mem::MaybeUninit<DltShm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltShm>(),
        56usize,
        concat!("Size of: ", stringify!(DltShm))
    );
    assert_eq!(
        ::std::mem::align_of::<DltShm>(),
        8usize,
        concat!("Alignment of ", stringify!(DltShm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shmfd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltShm),
            "::",
            stringify!(shmfd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltShm),
            "::",
            stringify!(sem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DltShm),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltShmBlockHead {
    pub head: [::std::os::raw::c_char; 4usize],
    pub status: ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DltShmBlockHead() {
    const UNINIT: ::std::mem::MaybeUninit<DltShmBlockHead> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltShmBlockHead>(),
        12usize,
        concat!("Size of: ", stringify!(DltShmBlockHead))
    );
    assert_eq!(
        ::std::mem::align_of::<DltShmBlockHead>(),
        4usize,
        concat!("Alignment of ", stringify!(DltShmBlockHead))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltShmBlockHead),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltShmBlockHead),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltShmBlockHead),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = " Initialise the shared memory on the client side.\n This function must be called before using further shm functions.\n @param buf pointer to shm structure\n @param name the name of the shm, must be the same for server and client\n @return negative value if there was an error"]
    pub fn dlt_shm_init_client(
        buf: *mut DltShm,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialise the shared memory on the server side.\n This function must be called before using further shm functions.\n @param buf pointer to shm structure\n @param name the name of the shm, must be the same for server and client\n @param size the requested size of the shm\n @return negative value if there was an error"]
    pub fn dlt_shm_init_server(
        buf: *mut DltShm,
        name: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Push data from client onto the shm.\n @param buf pointer to shm structure\n @param data1 pointer to first data block to be written, null if not used\n @param size1 size in bytes of first data block to be written, 0 if not used\n @param data2 pointer to second data block to be written, null if not used\n @param size2 size in bytes of second data block to be written, 0 if not used\n @param data3 pointer to third data block to be written, null if not used\n @param size3 size in bytes of third data block to be written, 0 if not used\n @return negative value if there was an error"]
    pub fn dlt_shm_push(
        buf: *mut DltShm,
        data1: *const ::std::os::raw::c_uchar,
        size1: ::std::os::raw::c_uint,
        data2: *const ::std::os::raw::c_uchar,
        size2: ::std::os::raw::c_uint,
        data3: *const ::std::os::raw::c_uchar,
        size3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pull data from shm.\n This function should be called from client.\n Data is deleted from shm after this call.\n @param buf pointer to shm structure\n @param data pointer to buffer where data is to be written\n @param size maximum size to be written into buffer\n @return negative value if there was an error"]
    pub fn dlt_shm_pull(
        buf: *mut DltShm,
        data: *mut ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy message from shm.\n This function should be called from server.\n Data is not deleted from shm after this call.\n @param buf pointer to shm structure\n @param data pointer to buffer where data is to be written\n @param size maximum size to be written into buffer\n @return negative value if there was an error"]
    pub fn dlt_shm_copy(
        buf: *mut DltShm,
        data: *mut ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete message from shm.\n This function should be called from server.\n This function should be called after each succesful copy.\n @param buf pointer to shm structure\n @return negative value if there was an error"]
    pub fn dlt_shm_remove(buf: *mut DltShm) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Print information about shm.\n @param buf pointer to shm structure"]
    pub fn dlt_shm_info(buf: *mut DltShm);
}
extern "C" {
    #[doc = " Print status about shm.\n @param buf pointer to shm structure"]
    pub fn dlt_shm_status(buf: *mut DltShm);
}
extern "C" {
    #[doc = " Deinitialise the shared memory on the client side.\n @param buf pointer to shm structure\n @return negative value if there was an error"]
    pub fn dlt_shm_free_client(buf: *mut DltShm) -> DltReturnValue;
}
extern "C" {
    #[doc = " Returns the total size of the shm.\n @param buf pointer to shm structure\n @return size of the shared memory."]
    pub fn dlt_shm_get_total_size(buf: *mut DltShm) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the used size in the shm.\n @param buf pointer to shm structure\n @return size of the shared memory."]
    pub fn dlt_shm_get_used_size(buf: *mut DltShm) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of messages in the shm.\n @param buf pointer to shm structure\n @return size of the shared memory."]
    pub fn dlt_shm_get_message_count(buf: *mut DltShm) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset pointers and counters when shm corrupted.\n @param buf pointer to shm structure\n @return size of the shared memory."]
    pub fn dlt_shm_reset(buf: *mut DltShm) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Recover to find next valid message.\n @param buf pointer to shm structure\n @return size of the shared memory."]
    pub fn dlt_shm_recover(buf: *mut DltShm) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deinitialise the shared memory on the server side.\n @param buf pointer to shm structure\n @param name name of the shared memory\n @return negative value if there was an error"]
    pub fn dlt_shm_free_server(
        buf: *mut DltShm,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
#[doc = " This structure is used for every context used in an application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltContext {
    #[doc = "< context id"]
    pub contextID: [::std::os::raw::c_char; 4usize],
    #[doc = "< offset in user-application context field"]
    pub log_level_pos: i32,
    #[doc = "< pointer to the log level"]
    pub log_level_ptr: *mut i8,
    #[doc = "< pointer to the trace status"]
    pub trace_status_ptr: *mut i8,
    #[doc = "< message counter"]
    pub mcnt: u8,
}
#[test]
fn bindgen_test_layout_DltContext() {
    const UNINIT: ::std::mem::MaybeUninit<DltContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltContext>(),
        32usize,
        concat!("Size of: ", stringify!(DltContext))
    );
    assert_eq!(
        ::std::mem::align_of::<DltContext>(),
        8usize,
        concat!("Alignment of ", stringify!(DltContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contextID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContext),
            "::",
            stringify!(contextID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level_pos) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContext),
            "::",
            stringify!(log_level_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContext),
            "::",
            stringify!(log_level_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_status_ptr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContext),
            "::",
            stringify!(trace_status_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mcnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContext),
            "::",
            stringify!(mcnt)
        )
    );
}
#[doc = " This structure is used for context data used in an application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltContextData {
    #[doc = "< pointer to DltContext"]
    pub handle: *mut DltContext,
    #[doc = "< buffer for building log message"]
    pub buffer: *mut ::std::os::raw::c_uchar,
    #[doc = "< payload size"]
    pub size: i32,
    #[doc = "< log level"]
    pub log_level: i32,
    #[doc = "< trace status"]
    pub trace_status: i32,
    #[doc = "< number of arguments for extended header"]
    pub args_num: i32,
    #[doc = "< description of context"]
    pub context_description: *mut ::std::os::raw::c_char,
    #[doc = "< whether to use user-supplied timestamps"]
    pub use_timestamp: DltTimestampType,
    #[doc = "< user-supplied timestamp to use"]
    pub user_timestamp: u32,
    #[doc = "< verbose mode: 1 enabled, 0 disabled"]
    pub verbose_mode: i8,
}
#[test]
fn bindgen_test_layout_DltContextData() {
    const UNINIT: ::std::mem::MaybeUninit<DltContextData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltContextData>(),
        56usize,
        concat!("Size of: ", stringify!(DltContextData))
    );
    assert_eq!(
        ::std::mem::align_of::<DltContextData>(),
        8usize,
        concat!("Alignment of ", stringify!(DltContextData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContextData),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContextData),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContextData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContextData),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_status) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContextData),
            "::",
            stringify!(trace_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args_num) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContextData),
            "::",
            stringify!(args_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_description) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContextData),
            "::",
            stringify!(context_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_timestamp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContextData),
            "::",
            stringify!(use_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_timestamp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContextData),
            "::",
            stringify!(user_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verbose_mode) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DltContextData),
            "::",
            stringify!(verbose_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltUserInjectionCallback {
    pub service_id: u32,
    pub injection_callback: ::std::option::Option<
        unsafe extern "C" fn(
            service_id: u32,
            data: *mut ::std::os::raw::c_void,
            length: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub injection_callback_with_id: ::std::option::Option<
        unsafe extern "C" fn(
            service_id: u32,
            data: *mut ::std::os::raw::c_void,
            length: u32,
            priv_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_DltUserInjectionCallback() {
    const UNINIT: ::std::mem::MaybeUninit<DltUserInjectionCallback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltUserInjectionCallback>(),
        32usize,
        concat!("Size of: ", stringify!(DltUserInjectionCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<DltUserInjectionCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(DltUserInjectionCallback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUserInjectionCallback),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).injection_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUserInjectionCallback),
            "::",
            stringify!(injection_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).injection_callback_with_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUserInjectionCallback),
            "::",
            stringify!(injection_callback_with_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUserInjectionCallback),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltUserLogLevelChangedCallback {
    #[doc = "< Context ID"]
    pub contextID: [::std::os::raw::c_char; 4usize],
    #[doc = "< Log level"]
    pub log_level: i8,
    #[doc = "< Trace status"]
    pub trace_status: i8,
    pub log_level_changed_callback: ::std::option::Option<
        unsafe extern "C" fn(
            context_id: *mut ::std::os::raw::c_char,
            log_level: u8,
            trace_status: u8,
        ),
    >,
}
#[test]
fn bindgen_test_layout_DltUserLogLevelChangedCallback() {
    const UNINIT: ::std::mem::MaybeUninit<DltUserLogLevelChangedCallback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltUserLogLevelChangedCallback>(),
        16usize,
        concat!("Size of: ", stringify!(DltUserLogLevelChangedCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<DltUserLogLevelChangedCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(DltUserLogLevelChangedCallback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contextID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUserLogLevelChangedCallback),
            "::",
            stringify!(contextID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUserLogLevelChangedCallback),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_status) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUserLogLevelChangedCallback),
            "::",
            stringify!(trace_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level_changed_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUserLogLevelChangedCallback),
            "::",
            stringify!(log_level_changed_callback)
        )
    );
}
#[doc = " This structure is used in a table managing all contexts and the corresponding log levels in an application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlt_ll_ts_type {
    #[doc = "< Context ID"]
    pub contextID: [::std::os::raw::c_char; 4usize],
    #[doc = "< Log level"]
    pub log_level: i8,
    #[doc = "< Ptr to the log level"]
    pub log_level_ptr: *mut i8,
    #[doc = "< Trace status"]
    pub trace_status: i8,
    #[doc = "< Ptr to the trace status"]
    pub trace_status_ptr: *mut i8,
    #[doc = "< description of context"]
    pub context_description: *mut ::std::os::raw::c_char,
    #[doc = "< Table with pointer to injection functions and service ids"]
    pub injection_table: *mut DltUserInjectionCallback,
    pub nrcallbacks: u32,
    pub log_level_changed_callback: ::std::option::Option<
        unsafe extern "C" fn(
            context_id: *mut ::std::os::raw::c_char,
            log_level: u8,
            trace_status: u8,
        ),
    >,
}
#[test]
fn bindgen_test_layout_dlt_ll_ts_type() {
    const UNINIT: ::std::mem::MaybeUninit<dlt_ll_ts_type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dlt_ll_ts_type>(),
        64usize,
        concat!("Size of: ", stringify!(dlt_ll_ts_type))
    );
    assert_eq!(
        ::std::mem::align_of::<dlt_ll_ts_type>(),
        8usize,
        concat!("Alignment of ", stringify!(dlt_ll_ts_type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contextID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_ll_ts_type),
            "::",
            stringify!(contextID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_ll_ts_type),
            "::",
            stringify!(log_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_ll_ts_type),
            "::",
            stringify!(log_level_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_status) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_ll_ts_type),
            "::",
            stringify!(trace_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trace_status_ptr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_ll_ts_type),
            "::",
            stringify!(trace_status_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_description) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_ll_ts_type),
            "::",
            stringify!(context_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).injection_table) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_ll_ts_type),
            "::",
            stringify!(injection_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrcallbacks) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_ll_ts_type),
            "::",
            stringify!(nrcallbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_level_changed_callback) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_ll_ts_type),
            "::",
            stringify!(log_level_changed_callback)
        )
    );
}
#[doc = " @brief holds initial log-level for given appId:ctxId pair"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlt_env_ll_item {
    pub appId: [::std::os::raw::c_char; 4usize],
    pub ctxId: [::std::os::raw::c_char; 4usize],
    pub ll: i8,
}
#[test]
fn bindgen_test_layout_dlt_env_ll_item() {
    const UNINIT: ::std::mem::MaybeUninit<dlt_env_ll_item> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dlt_env_ll_item>(),
        9usize,
        concat!("Size of: ", stringify!(dlt_env_ll_item))
    );
    assert_eq!(
        ::std::mem::align_of::<dlt_env_ll_item>(),
        1usize,
        concat!("Alignment of ", stringify!(dlt_env_ll_item))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_env_ll_item),
            "::",
            stringify!(appId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctxId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_env_ll_item),
            "::",
            stringify!(ctxId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ll) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_env_ll_item),
            "::",
            stringify!(ll)
        )
    );
}
#[doc = " @brief holds all initial log-levels given via environment variable DLT_INITIAL_LOG_LEVEL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlt_env_ll_set {
    pub item: *mut dlt_env_ll_item,
    pub array_size: usize,
    pub num_elem: usize,
}
#[test]
fn bindgen_test_layout_dlt_env_ll_set() {
    const UNINIT: ::std::mem::MaybeUninit<dlt_env_ll_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dlt_env_ll_set>(),
        24usize,
        concat!("Size of: ", stringify!(dlt_env_ll_set))
    );
    assert_eq!(
        ::std::mem::align_of::<dlt_env_ll_set>(),
        8usize,
        concat!("Alignment of ", stringify!(dlt_env_ll_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).item) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_env_ll_set),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_env_ll_set),
            "::",
            stringify!(array_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_elem) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dlt_env_ll_set),
            "::",
            stringify!(num_elem)
        )
    );
}
#[doc = " This structure is used once for one application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DltUser {
    #[doc = "< ECU ID"]
    pub ecuID: [::std::os::raw::c_char; 4usize],
    #[doc = "< Application ID"]
    pub appID: [::std::os::raw::c_char; 4usize],
    #[doc = "< Handle to fifo of dlt daemon"]
    pub dlt_log_handle: ::std::os::raw::c_int,
    #[doc = "< Handle to own fifo"]
    pub dlt_user_handle: ::std::os::raw::c_int,
    #[doc = "< Handle message queue"]
    pub dlt_segmented_queue_read_handle: mqd_t,
    #[doc = "< Handle message queue"]
    pub dlt_segmented_queue_write_handle: mqd_t,
    #[doc = "< thread handle of segmented sending"]
    pub dlt_segmented_nwt_handle: pthread_t,
    #[doc = "< Target of logging: 1 to file, 0 to daemon"]
    pub dlt_is_file: i8,
    #[doc = "< Maximum size of existing file in case dlt_is_file=1"]
    pub filesize_max: ::std::os::raw::c_uint,
    pub dlt_ll_ts: *mut dlt_ll_ts_type,
    #[doc = "< Maximum number of contexts"]
    pub dlt_ll_ts_max_num_entries: u32,
    #[doc = "< Number of used contexts"]
    pub dlt_ll_ts_num_entries: u32,
    #[doc = "< Overflow marker, set to 1 on overflow, 0 otherwise"]
    pub overflow: i8,
    #[doc = "< Counts the number of lost messages"]
    pub overflow_counter: u32,
    #[doc = "< description of application"]
    pub application_description: *mut ::std::os::raw::c_char,
    #[doc = "< Receiver for internal user-defined messages from daemon"]
    pub receiver: DltReceiver,
    #[doc = "< Verbose mode enabled: 1 enabled, 0 disabled"]
    pub verbose_mode: i8,
    #[doc = "< Use extended header for non verbose: 1 enabled, 0 disabled"]
    pub use_extended_header_for_non_verbose: i8,
    #[doc = "< Send always session id: 1 enabled, 0 disabled"]
    pub with_session_id: i8,
    #[doc = "< Send always timestamp: 1 enabled, 0 disabled"]
    pub with_timestamp: i8,
    #[doc = "< Send always ecu id: 1 enabled, 0 disabled"]
    pub with_ecu_id: i8,
    #[doc = "< Local printing of log messages: 1 enabled, 0 disabled"]
    pub enable_local_print: i8,
    #[doc = "< Local print mode, controlled by environment variable"]
    pub local_print_mode: i8,
    #[doc = "< Injection msg availability: 1 disabled, 0 enabled (default)"]
    pub disable_injection_msg: i8,
    #[doc = "< Log state of external connection:\n 1 client connected,\n 0 not connected,\n -1 unknown"]
    pub log_state: i8,
    #[doc = "< Ring-buffer for buffering messages during startup and missing connection"]
    pub startup_buffer: DltBuffer,
    pub resend_buffer: *mut u8,
    #[doc = "< timeout used in dlt_user_atexit_blow_out_user_buffer, in 0.1 milliseconds"]
    pub timeout_at_exit_handler: u32,
    pub initial_ll_set: dlt_env_ll_set,
    #[doc = "< length of message buffer, by default: DLT_USER_BUF_MAX_SIZE"]
    pub log_buf_len: u16,
}
#[test]
fn bindgen_test_layout_DltUser() {
    const UNINIT: ::std::mem::MaybeUninit<DltUser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DltUser>(),
        248usize,
        concat!("Size of: ", stringify!(DltUser))
    );
    assert_eq!(
        ::std::mem::align_of::<DltUser>(),
        8usize,
        concat!("Alignment of ", stringify!(DltUser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecuID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(ecuID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(appID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlt_log_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(dlt_log_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlt_user_handle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(dlt_user_handle)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dlt_segmented_queue_read_handle) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(dlt_segmented_queue_read_handle)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dlt_segmented_queue_write_handle) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(dlt_segmented_queue_write_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlt_segmented_nwt_handle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(dlt_segmented_nwt_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlt_is_file) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(dlt_is_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filesize_max) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(filesize_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlt_ll_ts) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(dlt_ll_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlt_ll_ts_max_num_entries) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(dlt_ll_ts_max_num_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlt_ll_ts_num_entries) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(dlt_ll_ts_num_entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(overflow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_counter) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(overflow_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_description) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(application_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiver) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(receiver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verbose_mode) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(verbose_mode)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).use_extended_header_for_non_verbose) as usize - ptr as usize
        },
        145usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(use_extended_header_for_non_verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).with_session_id) as usize - ptr as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(with_session_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).with_timestamp) as usize - ptr as usize },
        147usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(with_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).with_ecu_id) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(with_ecu_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_local_print) as usize - ptr as usize },
        149usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(enable_local_print)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_print_mode) as usize - ptr as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(local_print_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_injection_msg) as usize - ptr as usize },
        151usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(disable_injection_msg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_state) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(log_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startup_buffer) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(startup_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resend_buffer) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(resend_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_at_exit_handler) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(timeout_at_exit_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_ll_set) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(initial_ll_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_buf_len) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(DltUser),
            "::",
            stringify!(log_buf_len)
        )
    );
}
pub type dlt_injection_callback_id = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: u32,
        arg2: *mut ::std::os::raw::c_void,
        arg3: u32,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type dlt_injection_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: u32,
        arg2: *mut ::std::os::raw::c_void,
        arg3: u32,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Initialize the generation of a DLT log message (intended for usage in verbose mode)\n This function has to be called first, when an application wants to send a new log messages.\n Following functions like dlt_user_log_write_string and dlt_user_log_write_finish must only be called,\n when return value is bigger than zero.\n @param handle pointer to an object containing information about one special logging context\n @param log pointer to an object containing information about logging context data\n @param loglevel this is the current log level of the log message to be sent\n @return Value from DltReturnValue enum, DLT_RETURN_TRUE if log level is matching"]
    pub fn dlt_user_log_write_start(
        handle: *mut DltContext,
        log: *mut DltContextData,
        loglevel: DltLogLevelType,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialize the generation of a DLT log message (intended for usage in non-verbose mode)\n This function has to be called first, when an application wants to send a new log messages.\n Following functions like dlt_user_log_write_string and dlt_user_log_write_finish must only be called,\n when return value is bigger than zero.\n @param handle pointer to an object containing information about one special logging context\n @param log pointer to an object containing information about logging context data\n @param loglevel this is the current log level of the log message to be sent\n @param messageid message id of message\n @return Value from DltReturnValue enum, DLT_RETURN_TRUE if log level is matching"]
    pub fn dlt_user_log_write_start_id(
        handle: *mut DltContext,
        log: *mut DltContextData,
        loglevel: DltLogLevelType,
        messageid: u32,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialize the generation of a DLT log message with given buffer from DLT application.\n This can be considered as replacement of dlt_user_log_write_start/dlt_user_log_write_start_id\n and other data functions like dlt_user_log_write_string. The fourth, fifth, and sixth arguments\n shall be prepared by DLT application; this function is only responsible for checking log\n level and setting the given values to context data. This function has to be called first,\n when an application is ready to send a new log message with given buffer. This function only\n works with combination of dlt_user_log_write_finish_w_given_buffer and the function must only be\n called, when return value is bigger than zero. The function only supports verbose mode as of now.\n @param handle pointer to an object containing information about one special logging context\n @param log pointer to an object containing information about logging context data\n @param loglevel this is the current log level of the log message to be sent\n @param buffer data with log message\n @param size buffer size\n @param args_num number of arguments in buffer\n @return Value from DltReturnValue enum, DLT_RETURN_TRUE if log level is matching"]
    pub fn dlt_user_log_write_start_w_given_buffer(
        handle: *mut DltContext,
        log: *mut DltContextData,
        loglevel: DltLogLevelType,
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
        args_num: i32,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Finishing the generation of a DLT log message and sending it to the DLT daemon.\n This function has to be called after writing all the log attributes of a log message.\n @param log pointer to an object containing information about logging context data\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_finish(log: *mut DltContextData) -> DltReturnValue;
}
extern "C" {
    #[doc = " Finishing the generation of a DLT log message and sending it to the DLT daemon without\n freeing log buffer. This function only works with combination of\n dlt_user_log_write_start_w_given_buffer. This function has to be called after writing all\n the log attributes of a log message.\n @param log pointer to an object containing information about logging context data\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_finish_w_given_buffer(log: *mut DltContextData) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a boolean parameter into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param data boolean parameter written into log message (mapped to uint8)\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_bool(log: *mut DltContextData, data: u8) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a boolean parameter with \"name\" attribute into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param data  boolean parameter written into log message (mapped to uint8)\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_bool_attr(
        log: *mut DltContextData,
        data: u8,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a float parameter into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param data float32_t parameter written into log message.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_float32(log: *mut DltContextData, data: float32_t) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a double parameter into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param data float64_t parameter written into log message.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_float64(log: *mut DltContextData, data: f64) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a float parameter with attributes into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name or @a unit is NULL, this function will add a corresponding attribute field with length 0\n and no content to the message for that attribute.\n\n @param log  pointer to an object containing information about logging context data\n @param data  float32_t parameter written into log message\n @param name  the \"name\" attribute (or NULL)\n @param unit  the \"unit\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_float32_attr(
        log: *mut DltContextData,
        data: float32_t,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a double parameter with attributes into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name or @a unit is NULL, this function will add a corresponding attribute field with length 0\n and no content to the message for that attribute.\n\n @param log  pointer to an object containing information about logging context data\n @param data  float64_t parameter written into log message\n @param name  the \"name\" attribute (or NULL)\n @param unit  the \"unit\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_float64_attr(
        log: *mut DltContextData,
        data: float64_t,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a uint parameter into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param data unsigned int parameter written into log message.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_uint(
        log: *mut DltContextData,
        data: ::std::os::raw::c_uint,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint8(log: *mut DltContextData, data: u8) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint16(log: *mut DltContextData, data: u16) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint32(log: *mut DltContextData, data: u32) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint64(log: *mut DltContextData, data: u64) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a uint parameter with attributes into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name or @a unit is NULL, this function will add a corresponding attribute field with length 0\n and no content to the message for that attribute.\n\n @param log  pointer to an object containing information about logging context data\n @param data  unsigned int parameter written into log message\n @param name  the \"name\" attribute (or NULL)\n @param unit  the \"unit\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_uint_attr(
        log: *mut DltContextData,
        data: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint8_attr(
        log: *mut DltContextData,
        data: u8,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint16_attr(
        log: *mut DltContextData,
        data: u16,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint32_attr(
        log: *mut DltContextData,
        data: u32,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint64_attr(
        log: *mut DltContextData,
        data: u64,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a uint parameter into a DLT log message. The output will be formatted as given by the parameter type.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param data unsigned int parameter written into log message.\n @param type The formatting type of the string output.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_uint8_formatted(
        log: *mut DltContextData,
        data: u8,
        type_: DltFormatType,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint16_formatted(
        log: *mut DltContextData,
        data: u16,
        type_: DltFormatType,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint32_formatted(
        log: *mut DltContextData,
        data: u32,
        type_: DltFormatType,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_uint64_formatted(
        log: *mut DltContextData,
        data: u64,
        type_: DltFormatType,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a pointer value architecture independent.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param data void* parameter written into log message.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_ptr(
        log: *mut DltContextData,
        data: *mut ::std::os::raw::c_void,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a int parameter into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param data int parameter written into log message.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_int(
        log: *mut DltContextData,
        data: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_int8(log: *mut DltContextData, data: i8) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_int16(log: *mut DltContextData, data: i16) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_int32(log: *mut DltContextData, data: i32) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_int64(log: *mut DltContextData, data: i64) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write an int parameter with attributes into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name or @a unit is NULL, this function will add a corresponding attribute field with length 0\n and no content to the message for that attribute.\n\n @param log  pointer to an object containing information about logging context data\n @param data  int parameter written into log message\n @param name  the \"name\" attribute (or NULL)\n @param unit  the \"unit\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_int_attr(
        log: *mut DltContextData,
        data: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_int8_attr(
        log: *mut DltContextData,
        data: i8,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_int16_attr(
        log: *mut DltContextData,
        data: i16,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_int32_attr(
        log: *mut DltContextData,
        data: i32,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    pub fn dlt_user_log_write_int64_attr(
        log: *mut DltContextData,
        data: i64,
        name: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a null terminated ASCII string into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param text pointer to the parameter written into log message containing null termination.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_string(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a potentially non-null-terminated ASCII string into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param text pointer to the parameter written into log message\n @param length length in bytes of @a text (without any termination character)\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_sized_string(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        length: u16,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a constant null terminated ASCII string into a DLT log message.\n In non verbose mode DLT parameter will not be sent at all.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param text pointer to the parameter written into log message containing null termination.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_constant_string(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a constant, potentially non-null-terminated ASCII string into a DLT log message.\n In non verbose mode DLT parameter will not be sent at all.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param text pointer to the parameter written into log message\n @param length length in bytes of @a text (without any termination character)\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_sized_constant_string(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        length: u16,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a null terminated UTF8 string into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param text pointer to the parameter written into log message containing null termination.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_utf8_string(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a potentially non-null-terminated UTF8 string into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param text pointer to the parameter written into log message\n @param length length in bytes of @a text (without any termination character)\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_sized_utf8_string(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        length: u16,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a constant null terminated UTF8 string into a DLT log message.\n In non verbose mode DLT parameter will not be sent at all.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param text pointer to the parameter written into log message containing null termination.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_constant_utf8_string(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a constant, potentially non-null-terminated UTF8 string into a DLT log message.\n In non verbose mode DLT parameter will not be sent at all.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param text pointer to the parameter written into log message\n @param length length in bytes of @a text (without any termination character)\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_sized_constant_utf8_string(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        length: u16,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a null-terminated ASCII string with \"name\" attribute into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param text  pointer to the parameter written into log message containing null termination\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_string_attr(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a potentially non-null-terminated ASCII string with \"name\" attribute into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param text  pointer to the parameter written into log message\n @param length  length in bytes of @a text (without any termination character)\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_sized_string_attr(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        length: u16,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a constant, null-terminated ASCII string with \"name\" attribute into a DLT log message.\n In non-verbose mode, this parameter will not be sent at all.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param text  pointer to the parameter written into log message containing null termination\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_constant_string_attr(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a constant, potentially non-null-terminated ASCII string with \"name\" attribute into a DLT log message.\n In non-verbose mode, this parameter will not be sent at all.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param text  pointer to the parameter written into log message\n @param length  length in bytes of @a text (without any termination character)\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_sized_constant_string_attr(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        length: u16,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a null-terminated UTF-8 string with \"name\" attribute into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param text  pointer to the parameter written into log message containing null termination\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_utf8_string_attr(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a potentially non-null-terminated UTF-8 string with \"name\" attribute into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param text  pointer to the parameter written into log message\n @param length  length in bytes of @a text (without any termination character)\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_sized_utf8_string_attr(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        length: u16,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a constant, null-terminated UTF8 string with \"name\" attribute into a DLT log message.\n In non-verbose mode, this parameter will not be sent at all.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param text  pointer to the parameter written into log message containing null termination\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_constant_utf8_string_attr(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a constant, potentially non-null-terminated UTF8 string with \"name\" attribute into a DLT log message.\n In non-verbose mode, this parameter will not be sent at all.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param text  pointer to the parameter written into log message\n @param length  length in bytes of @a text (without any termination character)\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_sized_constant_utf8_string_attr(
        log: *mut DltContextData,
        text: *const ::std::os::raw::c_char,
        length: u16,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a binary memory block into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param data pointer to the parameter written into log message.\n @param length length in bytes of the parameter written into log message.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_raw(
        log: *mut DltContextData,
        data: *mut ::std::os::raw::c_void,
        length: u16,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a binary memory block into a DLT log message.\n dlt_user_log_write_start has to be called before adding any attributes to the log message.\n Finish sending log message by calling dlt_user_log_write_finish.\n @param log pointer to an object containing information about logging context data\n @param data pointer to the parameter written into log message.\n @param length length in bytes of the parameter written into log message.\n @param type the format information.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_write_raw_formatted(
        log: *mut DltContextData,
        data: *mut ::std::os::raw::c_void,
        length: u16,
        type_: DltFormatType,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a binary memory block with \"name\" attribute into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param data  pointer to the parameter written into log message.\n @param length  length in bytes of the parameter written into log message\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_raw_attr(
        log: *mut DltContextData,
        data: *const ::std::os::raw::c_void,
        length: u16,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a binary memory block with \"name\" attribute into a DLT log message.\n dlt_user_log_write_start has to be called before adding any parameters to the log message.\n Finish building a log message by calling dlt_user_log_write_finish.\n\n If @a name is NULL, this function will add an attribute field with length 0\n and no content to the message.\n\n @param log  pointer to an object containing information about logging context data\n @param data  pointer to the parameter written into log message.\n @param length  length in bytes of the parameter written into log message\n @param type  the format information\n @param name  the \"name\" attribute (or NULL)\n @return value from DltReturnValue enum"]
    pub fn dlt_user_log_write_raw_formatted_attr(
        log: *mut DltContextData,
        data: *const ::std::os::raw::c_void,
        length: u16,
        type_: DltFormatType,
        name: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Trace network message\n @param handle pointer to an object containing information about one special logging context\n @param nw_trace_type type of network trace (DLT_NW_TRACE_IPC, DLT_NW_TRACE_CAN, DLT_NW_TRACE_FLEXRAY, or DLT_NW_TRACE_MOST)\n @param header_len length of network message header\n @param header pointer to network message header\n @param payload_len length of network message payload\n @param payload pointer to network message payload\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_trace_network(
        handle: *mut DltContext,
        nw_trace_type: DltNetworkTraceType,
        header_len: u16,
        header: *mut ::std::os::raw::c_void,
        payload_len: u16,
        payload: *mut ::std::os::raw::c_void,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Trace network message, truncated if necessary.\n @param handle pointer to an object containing information about logging context\n @param nw_trace_type type of network trace (DLT_NW_TRACE_IPC, DLT_NW_TRACE_CAN, DLT_NW_TRACE_FLEXRAY, or DLT_NW_TRACE_MOST)\n @param header_len length of network message header\n @param header pointer to network message header\n @param payload_len length of network message payload\n @param payload pointer to network message payload\n @param allow_truncate Set to > 0 to allow truncating of the message if it is too large.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_trace_network_truncated(
        handle: *mut DltContext,
        nw_trace_type: DltNetworkTraceType,
        header_len: u16,
        header: *mut ::std::os::raw::c_void,
        payload_len: u16,
        payload: *mut ::std::os::raw::c_void,
        allow_truncate: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Trace network message in segmented asynchronous mode.\n The sending of the data is done in a separate thread.\n Please note that handle must exist for the lifetime of the application, because\n data chunks are sent asynchronously in undetermined future time.\n @param handle pointer to an object containing information about logging context\n @param nw_trace_type type of network trace (DLT_NW_TRACE_IPC, DLT_NW_TRACE_CAN, DLT_NW_TRACE_FLEXRAY, or DLT_NW_TRACE_MOST)\n @param header_len length of network message header\n @param header pointer to network message header\n @param payload_len length of network message payload\n @param payload pointer to network message payload\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_trace_network_segmented(
        handle: *mut DltContext,
        nw_trace_type: DltNetworkTraceType,
        header_len: u16,
        header: *mut ::std::os::raw::c_void,
        payload_len: u16,
        payload: *mut ::std::os::raw::c_void,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialize the user lib communication with daemon.\n This function has to be called first, before using any DLT user lib functions.\n @return Value from DltReturnValue enum"]
    pub fn dlt_init() -> DltReturnValue;
}
extern "C" {
    #[doc = " Initialize the user lib writing only to file.\n This function has to be called first, before using any DLT user lib functions.\n @param name name of an optional log file\n @return Value from DltReturnValue enum"]
    pub fn dlt_init_file(name: *const ::std::os::raw::c_char) -> DltReturnValue;
}
extern "C" {
    #[doc = " Set maximum file size if lib is configured to write only to file.\n This function has to be called after dlt_init_file().\n @param filesize maximum file size\n @return Value from DltReturnValue enum"]
    pub fn dlt_set_filesize_max(filesize: ::std::os::raw::c_uint) -> DltReturnValue;
}
extern "C" {
    #[doc = " Terminate the user lib.\n This function has to be called when finishing using the DLT user lib.\n @return Value from DltReturnValue enum"]
    pub fn dlt_free() -> DltReturnValue;
}
extern "C" {
    #[doc = " Check the library version of DLT library.\n @param user_major_version the major version to be compared\n @param user_minor_version the minor version to be compared\n @return Value from DltReturnValue enum, DLT_RETURN_ERROR if there is a mismatch"]
    pub fn dlt_check_library_version(
        user_major_version: *const ::std::os::raw::c_char,
        user_minor_version: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Register an application in the daemon.\n @param apid four byte long character array with the application id\n @param description long name of the application\n @return Value from DltReturnValue enum"]
    pub fn dlt_register_app(
        apid: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Unregister an application in the daemon.\n This function has to be called when finishing using an application.\n @return Value from DltReturnValue enum"]
    pub fn dlt_unregister_app() -> DltReturnValue;
}
extern "C" {
    #[doc = " Unregister an application in the daemon and also flushes the buffered logs.\n This function has to be called when finishing using an application.\n @return Value from DltReturnValue enum"]
    pub fn dlt_unregister_app_flush_buffered_logs() -> DltReturnValue;
}
extern "C" {
    #[doc = " Get the application id\n @param four byte long character array to store the application id\n @return Value from DltReturnValue enum"]
    pub fn dlt_get_appid(appid: *mut ::std::os::raw::c_char) -> DltReturnValue;
}
extern "C" {
    #[doc = " Register a context in the daemon.\n This function has to be called before first usage of the context.\n @param handle pointer to an object containing information about one special logging context\n @param contextid four byte long character array with the context id\n @param description long name of the context\n @return Value from DltReturnValue enum"]
    pub fn dlt_register_context(
        handle: *mut DltContext,
        contextid: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Register a context in the daemon with pre-defined log level and pre-defined trace status.\n This function has to be called before first usage of the context.\n @param handle pointer to an object containing information about one special logging context\n @param contextid four byte long character array with the context id\n @param description long name of the context\n @param loglevel This is the log level to be pre-set for this context\n        (DLT_LOG_DEFAULT is not allowed here)\n @param tracestatus This is the trace status to be pre-set for this context\n        (DLT_TRACE_STATUS_DEFAULT is not allowed here)\n @return Value from DltReturnValue enum"]
    pub fn dlt_register_context_ll_ts(
        handle: *mut DltContext,
        contextid: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        loglevel: ::std::os::raw::c_int,
        tracestatus: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Register a context in the daemon with log level changed callback fn.\n This function is introduced to avoid missing of LL change callback during registration\n @param handle pointer to an object containing information about one special logging context\n @param contextid four byte long character array with the context id\n @param description long name of the context\n @param *dlt_log_level_changed_callback This is the fn which will be called when log level is changed\n @return Value from DltReturnValue enum"]
    pub fn dlt_register_context_llccb(
        handle: *mut DltContext,
        contextid: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        dlt_log_level_changed_callback: ::std::option::Option<
            unsafe extern "C" fn(
                context_id: *mut ::std::os::raw::c_char,
                log_level: u8,
                trace_status: u8,
            ),
        >,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Unregister a context in the DLT daemon.\n This function has to be called when finishing using a context.\n @param handle pointer to an object containing information about one special logging context\n @return Value from DltReturnValue enum"]
    pub fn dlt_unregister_context(handle: *mut DltContext) -> DltReturnValue;
}
extern "C" {
    #[doc = " Set maximum timeout for re-sending at exit\n @param timeout_in_milliseconds maximum time to wait until giving up re-sending, default 10000 (equals to 10 seconds)"]
    pub fn dlt_set_resend_timeout_atexit(timeout_in_milliseconds: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the logging mode used by the daemon.\n The logging mode is stored persistantly by the daemon.\n @see DltUserLogMode\n @param mode the new logging mode used by the daemon: off, extern, internal, both.\n @return Value from DltReturnValue enum"]
    pub fn dlt_set_log_mode(mode: DltUserLogMode) -> DltReturnValue;
}
extern "C" {
    #[doc = " Get the state of the connected client to the daemon.\n The user application gets a message, when client is connected or disconnected.\n This value contains the last state.\n It needs some time until the application gets state from the daemon.\n Until then the state is \"unknown state\".\n @return -1 = unknown state, 0 = client not connected, 1 = client connected"]
    pub fn dlt_get_log_state() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register callback function called when injection message was received\n @param handle pointer to an object containing information about one special logging context\n @param service_id the service id to be waited for\n @param (*dlt_injection_callback) function pointer to callback function\n @return Value from DltReturnValue enum"]
    pub fn dlt_register_injection_callback(
        handle: *mut DltContext,
        service_id: u32,
        dlt_injection_callback: ::std::option::Option<
            unsafe extern "C" fn(
                service_id: u32,
                data: *mut ::std::os::raw::c_void,
                length: u32,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Register callback function with private data called when injection message was received\n @param handle pointer to an object containing information about one special logging context\n @param service_id the service id to be waited for\n @param (*dlt_injection_callback) function pointer to callback function\n @param priv private data\n @return Value from DltReturnValue enum"]
    pub fn dlt_register_injection_callback_with_id(
        handle: *mut DltContext,
        service_id: u32,
        dlt_injection_callback: ::std::option::Option<
            unsafe extern "C" fn(
                service_id: u32,
                data: *mut ::std::os::raw::c_void,
                length: u32,
                priv_data: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        priv_: *mut ::std::os::raw::c_void,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Register callback function called when log level of context was changed\n @param handle pointer to an object containing information about one special logging context\n @param (*dlt_log_level_changed_callback) function pointer to callback function\n @return Value from DltReturnValue enum"]
    pub fn dlt_register_log_level_changed_callback(
        handle: *mut DltContext,
        dlt_log_level_changed_callback: ::std::option::Option<
            unsafe extern "C" fn(
                context_id: *mut ::std::os::raw::c_char,
                log_level: u8,
                trace_status: u8,
            ),
        >,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Switch to verbose mode\n @return Value from DltReturnValue enum"]
    pub fn dlt_verbose_mode() -> DltReturnValue;
}
extern "C" {
    #[doc = " Check the version of dlt library with library version used of the application.\n @param user_major_version version number of application - see dlt_version.h\n @param user_minor_version version number of application - see dlt_version.h\n  @return Value from DltReturnValue enum, DLT_RETURN_ERROR if there is a mismatch"]
    pub fn dlt_user_check_library_version(
        user_major_version: *const ::std::os::raw::c_char,
        user_minor_version: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Switch to non-verbose mode\n\n This does not force all messages to be sent as Non-Verbose ones, as that does not make much sense.\n Instead, it +allows+ the sending of both Verbose and Non-Verbose messages, depending on which APIs\n are being called."]
    pub fn dlt_nonverbose_mode() -> DltReturnValue;
}
extern "C" {
    #[doc = " Use extended header in non verbose mode.\n Enabled by default.\n @param use_extended_header_for_non_verbose Use extended header for non verbose mode if true\n @return Value from DltReturnValue enum"]
    pub fn dlt_use_extended_header_for_non_verbose(
        use_extended_header_for_non_verbose: i8,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Send session id configuration.\n Enabled by default.\n @param with_session_id Send session id in each message if enabled\n @return Value from DltReturnValue enum"]
    pub fn dlt_with_session_id(with_session_id: i8) -> DltReturnValue;
}
extern "C" {
    #[doc = " Send timestamp configuration.\n Enabled by default.\n @param with_timestamp Send timestamp id in each message if enabled\n @return Value from DltReturnValue enum"]
    pub fn dlt_with_timestamp(with_timestamp: i8) -> DltReturnValue;
}
extern "C" {
    #[doc = " Send ecu id configuration.\n Enabled by default.\n @param with_ecu_id Send ecu id in each message if enabled\n @return Value from DltReturnValue enum"]
    pub fn dlt_with_ecu_id(with_ecu_id: i8) -> DltReturnValue;
}
extern "C" {
    #[doc = " Set maximum logged log level and trace status of application\n\n @param loglevel This is the log level to be set for the whole application\n @param tracestatus This is the trace status to be set for the whole application\n @return Value from DltReturnValue enum"]
    pub fn dlt_set_application_ll_ts_limit(
        loglevel: DltLogLevelType,
        tracestatus: DltTraceStatusType,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " @brief adjust log-level based on values given through environment\n\n Iterate over the set of items, and find the best match.\n For any item that matches, the one with the highest priority is selected and that\n log-level is returned.\n\n Priorities are determined as follows:\n - no apid, no ctid only ll given in item: use ll with prio 1\n - no apid, ctid matches: use ll with prio 2\n - no ctid, apid matches: use ll with prio 3\n - apid, ctid matches: use ll with prio 4\n\n @param ll_set\n @param apid\n @param ctid\n @param ll\n If no item matches or in case of error, the original log-level (\\param ll) is returned"]
    pub fn dlt_env_adjust_ll_from_env(
        ll_set: *const dlt_env_ll_set,
        apid: *const ::std::os::raw::c_char,
        ctid: *const ::std::os::raw::c_char,
        ll: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief extract log-level settings from given string\n\n Scan \\param env for setttings like apid:ctid:log-level and store them\n in given \\param ll_set\n\n @param env reference to a string to be parsed, after parsing env will point after the last parse character\n @param ll_set set of log-level extracted from given string\n\n @return 0 on success\n @return -1 on failure"]
    pub fn dlt_env_extract_ll_set(
        env: *mut *mut ::std::os::raw::c_char,
        ll_set: *mut dlt_env_ll_set,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dlt_env_free_ll_set(ll_set: *mut dlt_env_ll_set);
}
extern "C" {
    #[doc = " Enable local printing of messages\n @return Value from DltReturnValue enum"]
    pub fn dlt_enable_local_print() -> DltReturnValue;
}
extern "C" {
    #[doc = " Disable local printing of messages\n @return Value from DltReturnValue enum"]
    pub fn dlt_disable_local_print() -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a null terminated ASCII string into a DLT log message.\n @param handle pointer to an object containing information about one special logging context\n @param loglevel this is the current log level of the log message to be sent\n @param text pointer to the ASCII string written into log message containing null termination.\n @return Value from DltReturnValue enum"]
    pub fn dlt_log_string(
        handle: *mut DltContext,
        loglevel: DltLogLevelType,
        text: *const ::std::os::raw::c_char,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a null terminated ASCII string and an integer value into a DLT log message.\n @param handle pointer to an object containing information about one special logging context\n @param loglevel this is the current log level of the log message to be sent\n @param text pointer to the ASCII string written into log message containing null termination.\n @param data integer value written into the log message\n @return Value from DltReturnValue enum"]
    pub fn dlt_log_string_int(
        handle: *mut DltContext,
        loglevel: DltLogLevelType,
        text: *const ::std::os::raw::c_char,
        data: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write a null terminated ASCII string and an unsigned integer value into a DLT log message.\n @param handle pointer to an object containing information about one special logging context\n @param loglevel this is the current log level of the log message to be sent\n @param text pointer to the ASCII string written into log message containing null termination.\n @param data unsigned integer value written into the log message\n @return Value from DltReturnValue enum"]
    pub fn dlt_log_string_uint(
        handle: *mut DltContext,
        loglevel: DltLogLevelType,
        text: *const ::std::os::raw::c_char,
        data: ::std::os::raw::c_uint,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write an integer value into a DLT log message.\n @param handle pointer to an object containing information about one special logging context\n @param loglevel this is the current log level of the log message to be sent\n @param data integer value written into the log message\n @return Value from DltReturnValue enum"]
    pub fn dlt_log_int(
        handle: *mut DltContext,
        loglevel: DltLogLevelType,
        data: ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write an unsigned integer value into a DLT log message.\n @param handle pointer to an object containing information about one special logging context\n @param loglevel this is the current log level of the log message to be sent\n @param data unsigned integer value written into the log message\n @return Value from DltReturnValue enum"]
    pub fn dlt_log_uint(
        handle: *mut DltContext,
        loglevel: DltLogLevelType,
        data: ::std::os::raw::c_uint,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write an unsigned integer value into a DLT log message.\n @param handle pointer to an object containing information about one special logging context\n @param loglevel this is the current log level of the log message to be sent\n @param data pointer to the parameter written into log message.\n @param length length in bytes of the parameter written into log message.\n @return Value from DltReturnValue enum"]
    pub fn dlt_log_raw(
        handle: *mut DltContext,
        loglevel: DltLogLevelType,
        data: *mut ::std::os::raw::c_void,
        length: u16,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Write marker message to DLT.\n @return Value from DltReturnValue enum"]
    pub fn dlt_log_marker() -> DltReturnValue;
}
extern "C" {
    #[doc = " Get the total size and available size of the shared memory buffer between daemon and applications.\n This information is useful to control the flow control between applications and daemon.\n For example only 50% of the buffer should be used for file transfer.\n @param total_size total size of buffer in bytes\n @param used_size used size of buffer in bytes\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_check_buffer(
        total_size: *mut ::std::os::raw::c_int,
        used_size: *mut ::std::os::raw::c_int,
    ) -> DltReturnValue;
}
extern "C" {
    #[doc = " Try to resend log message in the user buffer. Stops if the dlt_uptime is bigger than\n dlt_uptime() + DLT_USER_ATEXIT_RESEND_BUFFER_EXIT_TIMEOUT. A pause between the resending\n attempts can be defined with DLT_USER_ATEXIT_RESEND_BUFFER_SLEEP\n @return number of messages in the user buffer"]
    pub fn dlt_user_atexit_blow_out_user_buffer() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Try to resend log message in the user buffer.\n @return Value from DltReturnValue enum"]
    pub fn dlt_user_log_resend_buffer() -> DltReturnValue;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
